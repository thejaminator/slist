{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Slist Documentation","text":"<p>Slist is a typesafe list implementation for Python that provides enhanced method chaining capabilities and additional utility functions.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83d\udd12 Type-safe: Full type hints and mypy support</li> <li>\u26d3\ufe0f Method chaining: Fluent interface for list operations</li> <li>\ud83d\udee0\ufe0f Rich functionality: Many utility methods for common operations</li> <li>\ud83d\ude80 Performance: Minimal overhead over Python's built-in list</li> <li>\ud83d\udd0d Clear API: Well-documented methods with intuitive names</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install slist\n</code></pre> <p>Or with Poetry:</p> <pre><code>poetry add slist\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from slist import Slist\n\n# Create a list of numbers\nnumbers = Slist([1, 2, 3, 4, 5])\n\n# Chain operations\nresult = numbers\\\n    .filter(lambda x: x % 2 == 0)\\  # Keep even numbers\n    .map(lambda x: x * 2)\\          # Double each number\n    .reversed()\\                    # Reverse the order\n    .add_one(10)                    # Add one more number\n\nprint(result)  # Slist([10, 8, 4])\n</code></pre>"},{"location":"#why-slist","title":"Why Slist?","text":"<p>Slist enhances Python's built-in list with:</p> <ol> <li>Method chaining for cleaner code</li> <li>Type-safe operations</li> <li>Additional utility methods</li> <li>Functional programming patterns</li> <li>Async operation support</li> </ol> <p>Check out the API Reference for detailed documentation of all available methods. </p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/thejaminator/slist/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>slist could always use more documentation, whether as part of the official slist docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/thejaminator/slist/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions   are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>slist</code> for local development.</p> <ol> <li>Fork the <code>slist</code> repo on GitHub.</li> <li> <p>Clone your fork locally</p> <pre><code>$ git clone git@github.com:your_name_here/slist.git\n</code></pre> </li> <li> <p>Ensure poetry is installed.</p> </li> <li> <p>Install dependencies and start your virtualenv:</p> <pre><code>$ poetry install -E test -E doc -E dev\n$ pip install tox\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass the    tests, including testing other Python versions, with tox:</p> <pre><code>$ poetry run pytest tests\n</code></pre> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put    your new functionality into a function with a docstring, and add the    feature to the list in README.md.</li> <li>The pull request should work for Python 3.6, 3.7, 3.8 and 3.9. Check    https://github.com/thejaminator/slist/actions    and make sure that the tests pass for all supported Python versions.</li> </ol>"},{"location":"contributing/#tips","title":"Tips","text":"<pre><code>$ poetry run pytest tests/test_slist.py\n</code></pre> <p>To run a subset of tests.</p>"},{"location":"contributing/#deploying","title":"Deploying","text":"<p>A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md). Then run:</p> <pre><code>$ poetry run bump2version patch # possible: major / minor / patch\n$ git push\n$ git push --tags\n</code></pre> <p>GitHub Actions will then deploy to PyPI if tests pass.</p>"},{"location":"api/slist/","title":"API Reference","text":""},{"location":"api/slist/#slist-class","title":"Slist Class","text":""},{"location":"api/slist/#slist.Slist","title":"slist.Slist","text":"<p>               Bases: <code>List[A]</code></p> Source code in <code>slist/__init__.py</code> <pre><code>class Slist(List[A]):\n    @staticmethod\n    def one(element: A) -&gt; Slist[A]:\n        \"\"\"Create a new Slist with a single element.\n\n        Parameters\n        ----------\n        element : A\n            The element to create the list with\n\n        Returns\n        -------\n        Slist[A]\n            A new Slist containing only the given element\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist.one(5)\n        Slist([5])\n        \"\"\"\n        return Slist([element])\n\n    @staticmethod\n    def one_option(element: Optional[A]) -&gt; Slist[A]:\n        \"\"\"Create a Slist with one element if it exists, otherwise empty list.\n\n        Equal to ``Slist.one(element).flatten_option()``\n\n        Parameters\n        ----------\n        element : Optional[A]\n            The element to create the list with, if it exists\n\n        Returns\n        -------\n        Slist[A]\n            A new Slist containing the element if it exists, otherwise empty\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist.one_option(5)\n        Slist([5])\n        &gt;&gt;&gt; Slist.one_option(None)\n        Slist([])\n        \"\"\"\n        return Slist([element]) if element is not None else Slist()\n\n    def any(self, predicate: Callable[[A], bool]) -&gt; bool:\n        \"\"\"Check if any element satisfies the predicate.\n\n        Parameters\n        ----------\n        predicate : Callable[[A], bool]\n            Function that takes an element and returns True/False\n\n        Returns\n        -------\n        bool\n            True if any element satisfies the predicate, False otherwise\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3, 4]).any(lambda x: x &gt; 3)\n        True\n        &gt;&gt;&gt; Slist([1, 2, 3]).any(lambda x: x &gt; 3)\n        False\n        \"\"\"\n        for x in self:\n            if predicate(x):\n                return True\n        return False\n\n    def all(self, predicate: Callable[[A], bool]) -&gt; bool:\n        \"\"\"Check if all elements satisfy the predicate.\n\n        Parameters\n        ----------\n        predicate : Callable[[A], bool]\n            Function that takes an element and returns True/False\n\n        Returns\n        -------\n        bool\n            True if all elements satisfy the predicate, False otherwise\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([2, 4, 6]).all(lambda x: x % 2 == 0)\n        True\n        &gt;&gt;&gt; Slist([2, 3, 4]).all(lambda x: x % 2 == 0)\n        False\n        \"\"\"\n        for x in self:\n            if not predicate(x):\n                return False\n        return True\n\n    def filter(self, predicate: Callable[[A], bool]) -&gt; Slist[A]:\n        \"\"\"Create a new Slist with only elements that satisfy the predicate.\n\n        Parameters\n        ----------\n        predicate : Callable[[A], bool]\n            Function that takes an element and returns True/False\n\n        Returns\n        -------\n        Slist[A]\n            A new Slist containing only elements that satisfy the predicate\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3, 4]).filter(lambda x: x % 2 == 0)\n        Slist([2, 4])\n        \"\"\"\n        return Slist(filter(predicate, self))\n\n    def map(self, func: Callable[[A], B]) -&gt; Slist[B]:\n        \"\"\"Transform each element using the given function.\n\n        Parameters\n        ----------\n        func : Callable[[A], B]\n            Function to apply to each element\n\n        Returns\n        -------\n        Slist[B]\n            A new Slist with transformed elements\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3]).map(lambda x: x * 2)\n        Slist([2, 4, 6])\n        \"\"\"\n        return Slist(func(item) for item in self)\n\n    @overload\n    def product(self: Sequence[A], other: Sequence[B], /) -&gt; Slist[Tuple[A, B]]: ...\n\n    @overload\n    def product(self: Sequence[A], other: Sequence[B], other1: Sequence[C], /) -&gt; Slist[Tuple[A, B, C]]: ...\n\n    @overload\n    def product(\n        self: Sequence[A], other: Sequence[B], other1: Sequence[C], other2: Sequence[D], /\n    ) -&gt; Slist[Tuple[A, B, C, D]]: ...\n\n    @overload\n    def product(\n        self: Sequence[A], other: Sequence[B], other1: Sequence[C], other2: Sequence[D], other3: Sequence[E], /\n    ) -&gt; Slist[Tuple[A, B, C, D, E]]: ...\n\n    @overload\n    def product(\n        self: Sequence[A],\n        other: Sequence[B],\n        other1: Sequence[C],\n        other2: Sequence[D],\n        other3: Sequence[E],\n        other4: Sequence[F],\n        /,\n    ) -&gt; Slist[Tuple[A, B, C, D, E, F]]: ...\n\n    def product(self: Sequence[A], *others: Sequence[Any]) -&gt; Slist[Tuple[Any, ...]]:\n        \"\"\"Compute the cartesian product with other sequences.\n\n        Parameters\n        ----------\n        *others : Sequence[Any]\n            The sequences to compute the product with\n\n        Returns\n        -------\n        Slist[Tuple[Any, ...]]\n            A new Slist containing tuples of all combinations\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2]).product(['a', 'b'])\n        Slist([(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')])\n        \"\"\"\n        return Slist(itertools.product(self, *others))\n\n    def map_2(self: Sequence[Tuple[B, C]], func: Callable[[B, C], D]) -&gt; Slist[D]:\n        \"\"\"Map a function over a sequence of 2-tuples.\n\n        Parameters\n        ----------\n        func : Callable[[B, C], D]\n            Function that takes two arguments and returns a value\n\n        Returns\n        -------\n        Slist[D]\n            A new Slist with the results of applying func to each tuple\n\n        Examples\n        --------\n        &gt;&gt;&gt; pairs = Slist([(1, 2), (3, 4)])\n        &gt;&gt;&gt; pairs.map_2(lambda x, y: x + y)\n        Slist([3, 7])\n        \"\"\"\n        return Slist(func(b, c) for b, c in self)\n\n    def map_enumerate(self, func: Callable[[int, A], B]) -&gt; Slist[B]:\n        \"\"\"Map a function over the list with indices.\n\n        Parameters\n        ----------\n        func : Callable[[int, A], B]\n            Function that takes an index and value and returns a new value\n\n        Returns\n        -------\n        Slist[B]\n            A new Slist with the results of applying func to each (index, value) pair\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist(['a', 'b', 'c']).map_enumerate(lambda i, x: f\"{i}:{x}\")\n        Slist(['0:a', '1:b', '2:c'])\n        \"\"\"\n        return Slist(func(idx, item) for idx, item in enumerate(self))\n\n    def flatten_option(self: Sequence[Optional[B]]) -&gt; Slist[B]:\n        \"\"\"Remove None values from a sequence of optional values.\n\n        Parameters\n        ----------\n        self : Sequence[Optional[B]]\n            A sequence containing optional values\n\n        Returns\n        -------\n        Slist[B]\n            A new Slist with all non-None values\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, None, 3, None, 5]).flatten_option()\n        Slist([1, 3, 5])\n        \"\"\"\n        return Slist([item for item in self if item is not None])\n\n    def flat_map_option(self, func: Callable[[A], Optional[B]]) -&gt; Slist[B]:\n        \"\"\"Apply a function that returns optional values and filter out Nones.\n\n        Parameters\n        ----------\n        func : Callable[[A], Optional[B]]\n            Function that takes a value and returns an optional value\n\n        Returns\n        -------\n        Slist[B]\n            A new Slist with all non-None results of applying func\n\n        Examples\n        --------\n        &gt;&gt;&gt; def safe_sqrt(x: float) -&gt; Optional[float]:\n        ...     return x ** 0.5 if x &gt;= 0 else None\n        &gt;&gt;&gt; Slist([4, -1, 9, -4, 16]).flat_map_option(safe_sqrt)\n        Slist([2.0, 3.0, 4.0])\n        \"\"\"\n        return self.map(func).flatten_option()\n\n    def upsample_if(self, predicate: Callable[[A], bool], upsample_by: int) -&gt; Slist[A]:\n        \"\"\"Repeat elements that satisfy a predicate.\n\n        Parameters\n        ----------\n        predicate : Callable[[A], bool]\n            Function that determines which elements to upsample\n        upsample_by : int\n            Number of times to repeat each matching element\n\n        Returns\n        -------\n        Slist[A]\n            A new Slist with matching elements repeated\n\n        Examples\n        --------\n        &gt;&gt;&gt; numbers = Slist([1, 2, 3, 4])\n        &gt;&gt;&gt; numbers.upsample_if(lambda x: x % 2 == 0, upsample_by=2)\n        Slist([1, 2, 2, 3, 4, 4])\n        \"\"\"\n        assert upsample_by &gt; 0, \"upsample_by must be positive\"\n        new_list = Slist[A]()\n        for item in self:\n            if predicate(item):\n                for _ in range(upsample_by):\n                    new_list.append(item)\n            else:\n                new_list.append(item)\n        return new_list\n\n    def flatten_list(self: Sequence[Sequence[B]]) -&gt; Slist[B]:\n        \"\"\"Flatten a sequence of sequences into a single list.\n\n        Parameters\n        ----------\n        self : Sequence[Sequence[B]]\n            A sequence of sequences to flatten\n\n        Returns\n        -------\n        Slist[B]\n            A new Slist with all elements from all sequences\n\n        Examples\n        --------\n        &gt;&gt;&gt; nested = Slist([[1, 2], [3, 4], [5, 6]])\n        &gt;&gt;&gt; nested.flatten_list()\n        Slist([1, 2, 3, 4, 5, 6])\n        \"\"\"\n        flat_list: Slist[B] = Slist()\n        for sublist in self:\n            for item in sublist:\n                flat_list.append(item)\n        return flat_list\n\n    def enumerated(self) -&gt; Slist[Tuple[int, A]]:\n        \"\"\"Create a list of tuples containing indices and values.\n\n        Returns\n        -------\n        Slist[Tuple[int, A]]\n            A new Slist of (index, value) tuples\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist(['a', 'b', 'c']).enumerated()\n        Slist([(0, 'a'), (1, 'b'), (2, 'c')])\n        \"\"\"\n        return Slist(enumerate(self))\n\n    def shuffle(self, seed: Optional[str] = None) -&gt; Slist[A]:\n        \"\"\"Create a new randomly shuffled list.\n\n        Parameters\n        ----------\n        seed : Optional[str], optional\n            Random seed for reproducibility, by default None\n\n        Returns\n        -------\n        Slist[A]\n            A new Slist with elements in random order\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3, 4]).shuffle(seed=\"42\")  # Reproducible shuffle\n        Slist([2, 4, 1, 3])\n        \"\"\"\n        new = self.copy()\n        random.Random(seed).shuffle(new)\n        return Slist(new)\n\n    def choice(\n        self,\n        seed: Optional[str] = None,\n        weights: Optional[List[int]] = None,\n    ) -&gt; A:\n        \"\"\"Randomly select an element from the list.\n\n        Parameters\n        ----------\n        seed : Optional[str], optional\n            Random seed for reproducibility, by default None\n        weights : Optional[List[int]], optional\n            List of weights for weighted random selection, by default None\n\n        Returns\n        -------\n        A\n            A randomly selected element\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3, 4]).choice(seed=\"42\")  # Reproducible choice\n        2\n        &gt;&gt;&gt; Slist([1, 2, 3]).choice(weights=[1, 2, 1])  # Weighted choice\n        2  # More likely to select 2 due to higher weight\n        \"\"\"\n        if weights:\n            return random.Random(seed).choices(self, weights=weights, k=1)[0]\n        else:\n            return random.Random(seed).choice(self)\n\n    def sample(self, n: int, seed: Optional[str] = None) -&gt; Slist[A]:\n        \"\"\"Randomly sample n elements from the list without replacement.\n\n        Parameters\n        ----------\n        n : int\n            Number of elements to sample\n        seed : Optional[str], optional\n            Random seed for reproducibility, by default None\n\n        Returns\n        -------\n        Slist[A]\n            A new Slist with n randomly selected elements\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3, 4, 5]).sample(3, seed=\"42\")\n        Slist([2, 4, 1])\n        \"\"\"\n        return Slist(random.Random(seed).sample(self, n))\n\n    def for_each(self, func: Callable[[A], None]) -&gt; Slist[A]:\n        \"\"\"Apply a side-effect function to each element and return the original list.\n\n        Parameters\n        ----------\n        func : Callable[[A], None]\n            Function to apply to each element for its side effects\n\n        Returns\n        -------\n        Slist[A]\n            The original list, unchanged\n\n        Examples\n        --------\n        &gt;&gt;&gt; nums = Slist([1, 2, 3])\n        &gt;&gt;&gt; nums.for_each(print)  # Prints each number\n        1\n        2\n        3\n        &gt;&gt;&gt; nums  # Original list is unchanged\n        Slist([1, 2, 3])\n        \"\"\"\n        for item in self:\n            func(item)\n        return self\n\n    def group_by(self, key: Callable[[A], CanHash]) -&gt; Slist[Group[CanHash, Slist[A]]]:\n        \"\"\"Group elements by a key function.\n\n        Parameters\n        ----------\n        key : Callable[[A], CanHash]\n            Function to compute the group key for each element\n\n        Returns\n        -------\n        Slist[Group[CanHash, Slist[A]]]\n            A new Slist of Groups, where each Group contains:\n                - key: The grouping key\n                - values: Slist of elements in that group\n\n        Examples\n        --------\n        &gt;&gt;&gt; numbers = Slist([1, 2, 3, 4])\n        &gt;&gt;&gt; groups = numbers.group_by(lambda x: x % 2)  # Group by even/odd\n        &gt;&gt;&gt; groups.map(lambda g: (g.key, list(g.values)))\n        Slist([(1, [1, 3]), (0, [2, 4])])\n        \"\"\"\n        d: typing.OrderedDict[CanHash, Slist[A]] = OrderedDict()\n        for elem in self:\n            k = key(elem)\n            if k in d:\n                d[k].append(elem)\n            else:\n                d[k] = Slist([elem])\n        return Slist(Group(key=key, values=value) for key, value in d.items())\n\n    @overload\n    def ungroup(self: Slist[Group[Any, Slist[C]]]) -&gt; Slist[C]: ...\n\n    @overload\n    def ungroup(self: Slist[Group[Any, Sequence[C]]]) -&gt; Slist[C]: ...\n\n    def ungroup(self: Slist[Group[Any, Slist[C]]] | Slist[Group[Any, Sequence[C]]]) -&gt; Slist[C]:\n        \"\"\"Convert a list of groups back into a flat list of values.\n\n        Parameters\n        ----------\n        self : Slist[Group[Any, Slist[C]]] | Slist[Group[Any, Sequence[C]]]\n            A list of groups to ungroup\n\n        Returns\n        -------\n        Slist[C]\n            A flat list containing all values from all groups\n\n        Examples\n        --------\n        &gt;&gt;&gt; groups = Slist([Group(0, [1, 2]), Group(1, [3, 4])])\n        &gt;&gt;&gt; groups.ungroup()\n        Slist([1, 2, 3, 4])\n        \"\"\"\n        casted: Slist[Group[Any, Slist[C]]] = self  # type: ignore\n        return casted.map_2(lambda _, values: values).flatten_list()\n\n    def map_on_group_values(self: Slist[Group[B, Slist[C]]], func: Callable[[Slist[C]], D]) -&gt; Slist[Group[B, D]]:\n        \"\"\"Apply a function to the values of each group.\n\n        Parameters\n        ----------\n        func : Callable[[Slist[C]], D]\n            Function to apply to each group's values\n\n        Returns\n        -------\n        Slist[Group[B, D]]\n            A new list of groups with transformed values\n\n        Examples\n        --------\n        &gt;&gt;&gt; groups = Slist([1, 2, 3, 4]).group_by(lambda x: x % 2)\n        &gt;&gt;&gt; groups.map_on_group_values(lambda values: sum(values))\n        Slist([Group(key=1, values=4), Group(key=0, values=6)])\n        \"\"\"\n        return self.map(lambda group: group.map_values(func))\n\n    def map_on_group_values_list(\n        self: Slist[Group[A, Sequence[B]]], func: Callable[[B], C]\n    ) -&gt; Slist[Group[A, Sequence[C]]]:\n        \"\"\"Apply a function to each element in each group's values.\n\n        Parameters\n        ----------\n        func : Callable[[B], C]\n            Function to apply to each element in each group's values\n\n        Returns\n        -------\n        Slist[Group[A, Sequence[C]]]\n            A new list of groups with transformed elements\n\n        Examples\n        --------\n        &gt;&gt;&gt; groups = Slist([Group(1, [1, 2]), Group(2, [3, 4])])\n        &gt;&gt;&gt; groups.map_on_group_values_list(lambda x: x * 2)\n        Slist([Group(1, [2, 4]), Group(2, [6, 8])])\n        \"\"\"\n        return self.map(lambda group: group.map_values(lambda values: Slist(values).map(func)))\n\n    def value_counts(self, key: Callable[[A], CanHash], sort: bool = True) -&gt; Slist[Group[CanHash, int]]:\n        \"\"\"Count occurrences of each unique value or key-derived value.\n\n        Parameters\n        ----------\n        key : Callable[[A], CanHash]\n            Function to extract the value to count by\n        sort : bool, default=True\n            If True, sorts the results by count in descending order\n\n        Returns\n        -------\n        Slist[Group[CanHash, int]]\n            A list of groups with keys and their counts\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist(['apple', 'banana', 'cherry']).value_counts(key=lambda x: x)\n        Slist([Group(key='apple', values=1), Group(key='banana', values=1), Group(key='cherry', values=1)])\n        \"\"\"\n        result = self.group_by(key).map_on_group_values(len)\n        if sort:\n            return result.sort_by(key=lambda group: group.values, reverse=True)\n        return result\n\n    def value_percentage(self, key: Callable[[A], CanHash], sort: bool = True) -&gt; Slist[Group[CanHash, float]]:\n        \"\"\"Count occurrences of each unique value or key-derived value.\n\n        Parameters\n        ----------\n        key : Callable[[A], CanHash]\n            Function to extract the value to count by\n        sort : bool, default=True\n            If True, sorts the results by percentage in descending order\n\n        Returns\n        -------\n        Slist[Group[CanHash, float]]\n            A list of groups with keys and their percentage of total\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist(['a', 'a', 'b']).value_percentage(key=lambda x: x)\n        Slist([Group(key='a', values=0.6666666666666666), Group(key='b', values=0.3333333333333333)])\n        \"\"\"\n        total = len(self)\n        if total == 0:\n            return Slist()\n\n        counts = self.value_counts(key, sort=False)\n        result = counts.map(lambda group: Group(key=group.key, values=group.values / total))  # type: ignore\n\n        if sort:\n            return result.sort_by(key=lambda group: group.values, reverse=True)\n        return result\n\n    def to_dict(self: Sequence[Tuple[CanHash, B]]) -&gt; typing.Dict[CanHash, B]:\n        \"\"\"\n        Transforms a Slist of key value pairs to a dictionary\n        &gt;&gt;&gt; Slist([(1, Slist([1, 1])), (2, Slist([2, 2])])).to_dict()\n        # Equivalent to\n        &gt;&gt;&gt; Slist([1, 1, 2, 2]).group_by(lambda x: x).to_dict()\n        {1: Slist([1, 1]), 2: Slist([2, 2])}\n        \"\"\"\n        return dict(self)\n\n    def to_set(self) -&gt; typing.Set[A]:\n        \"\"\"\n        Convert the Slist to a set.\n        \"\"\"\n        return set(self)\n\n    @staticmethod\n    def from_dict(a_dict: typing.Dict[CanHash, A]) -&gt; Slist[Tuple[CanHash, A]]:\n        \"\"\"Convert a dictionary to a Slist of tuple values.\n\n        Parameters\n        ----------\n        a_dict : Dict[CanHash, A]\n            Dictionary to convert\n\n        Returns\n        -------\n        Slist[Tuple[CanHash, A]]\n            List of key-value tuples from the dictionary\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist.from_dict({1: 'a', 2: 'b'})\n        Slist([(1, 'a'), (2, 'b')])\n        \"\"\"\n        return Slist(tup for tup in a_dict.items())\n\n    def for_each_enumerate(self, func: Callable[[int, A], None]) -&gt; Slist[A]:\n        \"\"\"Apply a side-effect function to each element with its index.\n\n        Parameters\n        ----------\n        func : Callable[[int, A], None]\n            Function taking an index and value, applied for side effects\n\n        Returns\n        -------\n        Slist[A]\n            The original list, unchanged\n\n        Examples\n        --------\n        &gt;&gt;&gt; nums = Slist(['a', 'b', 'c'])\n        &gt;&gt;&gt; nums.for_each_enumerate(lambda i, x: print(f\"{i}: {x}\"))\n        0: a\n        1: b\n        2: c\n        &gt;&gt;&gt; nums  # Original list is unchanged\n        Slist(['a', 'b', 'c'])\n        \"\"\"\n        for idx, item in enumerate(self):\n            func(idx, item)\n        return self\n\n    def max_option(self: Sequence[CanCompare]) -&gt; Optional[CanCompare]:\n        \"\"\"Get the maximum element if it exists.\n\n        Returns\n        -------\n        Optional[CanCompare]\n            Maximum element, or None if list is empty\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 3, 2]).max_option()\n        3\n        &gt;&gt;&gt; Slist([]).max_option()\n        None\n        \"\"\"\n        return max(self) if self else None\n\n    def max_by(self, key: Callable[[A], CanCompare]) -&gt; Optional[A]:\n        \"\"\"Get the element with maximum value by key function.\n\n        Parameters\n        ----------\n        key : Callable[[A], CanCompare]\n            Function to compute comparison value for each element\n\n        Returns\n        -------\n        Optional[A]\n            Element with maximum key value, or None if list is empty\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist(['a', 'bbb', 'cc']).max_by(len)\n        'bbb'\n        &gt;&gt;&gt; Slist([]).max_by(len)\n        None\n        \"\"\"\n        return max(self, key=key) if self.length &gt; 0 else None\n\n    def max_by_ordering(self, ordering: Callable[[A, A], bool]) -&gt; Optional[A]:\n        \"\"\"Get maximum element using custom ordering function.\n\n        Parameters\n        ----------\n        ordering : Callable[[A, A], bool]\n            Function that returns True if first argument should be considered larger\n\n        Returns\n        -------\n        Optional[A]\n            Maximum element by ordering, or None if list is empty\n\n        Examples\n        --------\n        &gt;&gt;&gt; # Custom ordering: consider numbers closer to 10 as \"larger\"\n        &gt;&gt;&gt; nums = Slist([1, 5, 8, 15])\n        &gt;&gt;&gt; nums.max_by_ordering(lambda x, y: abs(x-10) &lt; abs(y-10))\n        8\n        \"\"\"\n        theMax: Optional[A] = self.first_option\n        for currentItem in self:\n            if theMax is not None:\n                if ordering(theMax, currentItem):\n                    theMax = currentItem\n        return theMax\n\n    def min_option(self: Sequence[CanCompare]) -&gt; Optional[CanCompare]:\n        \"\"\"Get the minimum element if it exists.\n\n        Returns\n        -------\n        Optional[CanCompare]\n            Minimum element, or None if list is empty\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([3, 1, 2]).min_option()\n        1\n        &gt;&gt;&gt; Slist([]).min_option()\n        None\n        \"\"\"\n        return min(self) if self else None\n\n    def min_by(self, key: Callable[[A], CanCompare]) -&gt; Optional[A]:\n        \"\"\"Get the element with minimum value by key function.\n\n        Parameters\n        ----------\n        key : Callable[[A], CanCompare]\n            Function to compute comparison value for each element\n\n        Returns\n        -------\n        Optional[A]\n            Element with minimum key value, or None if list is empty\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist(['aaa', 'b', 'cc']).min_by(len)\n        'b'\n        &gt;&gt;&gt; Slist([]).min_by(len)\n        None\n        \"\"\"\n        return min(self, key=key) if self.length &gt; 0 else None\n\n    def min_by_ordering(self: Slist[CanCompare]) -&gt; Optional[CanCompare]:\n        \"\"\"Get minimum element using default ordering.\n\n        Returns\n        -------\n        Optional[CanCompare]\n            Minimum element, or None if list is empty\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([3, 1, 2]).min_by_ordering()\n        1\n        &gt;&gt;&gt; Slist([]).min_by_ordering()\n        None\n        \"\"\"\n        return min(self) if self else None\n\n    def get(self, index: int, or_else: B) -&gt; Union[A, B]:\n        \"\"\"Get element at index with fallback value.\n\n        Parameters\n        ----------\n        index : int\n            Index to get element from\n        or_else : B\n            Value to return if index is out of bounds\n\n        Returns\n        -------\n        Union[A, B]\n            Element at index if it exists, otherwise or_else value\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3]).get(1, -1)\n        2\n        &gt;&gt;&gt; Slist([1, 2, 3]).get(5, -1)\n        -1\n        \"\"\"\n        try:\n            return self.__getitem__(index)\n        except IndexError:\n            return or_else\n\n    def get_option(self, index: int) -&gt; Optional[A]:\n        \"\"\"Get element at index if it exists.\n\n        Parameters\n        ----------\n        index : int\n            Index to get element from\n\n        Returns\n        -------\n        Optional[A]\n            Element at index if it exists, otherwise None\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3]).get_option(1)\n        2\n        &gt;&gt;&gt; Slist([1, 2, 3]).get_option(5)\n        None\n        \"\"\"\n        try:\n            return self.__getitem__(index)\n        except IndexError:\n            return None\n\n    def pairwise(self) -&gt; Slist[Tuple[A, A]]:\n        \"\"\"Return overlapping pairs of consecutive elements.\n\n        Returns\n        -------\n        Slist[Tuple[A, A]]\n            List of tuples containing consecutive overlapping pairs\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3, 4]).pairwise()\n        Slist([(1, 2), (2, 3), (3, 4)])\n        &gt;&gt;&gt; Slist([1]).pairwise()\n        Slist([])\n        &gt;&gt;&gt; Slist([]).pairwise()\n        Slist([])\n\n        Notes\n        -----\n        Inspired by more-itertools pairwise function. Creates an iterator of\n        overlapping pairs from the input sequence.\n        \"\"\"\n        a, b = tee(self)\n        next(b, None)\n        return Slist(zip(a, b))\n\n    def print_length(self, printer: Callable[[str], None] = print, prefix: str = \"Slist Length: \") -&gt; Slist[A]:\n        \"\"\"Print the length of the list and return the original list.\n\n        Parameters\n        ----------\n        printer : Callable[[str], None], optional\n            Function to print the output, by default print\n        prefix : str, optional\n            Prefix string before the length, by default \"Slist Length: \"\n\n        Returns\n        -------\n        Slist[A]\n            The original list unchanged\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1,2,3]).print_length()\n        Slist Length: 3\n        Slist([1, 2, 3])\n        \"\"\"\n        string = f\"{prefix}{len(self)}\"\n        printer(string)\n        return self\n\n    @property\n    def is_empty(self) -&gt; bool:\n        \"\"\"Check if the list is empty.\n\n        Returns\n        -------\n        bool\n            True if the list has no elements\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([]).is_empty\n        True\n        &gt;&gt;&gt; Slist([1]).is_empty\n        False\n        \"\"\"\n        return len(self) == 0\n\n    @property\n    def not_empty(self) -&gt; bool:\n        \"\"\"Check if the list has any elements.\n\n        Returns\n        -------\n        bool\n            True if the list has at least one element\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1]).not_empty\n        True\n        &gt;&gt;&gt; Slist([]).not_empty\n        False\n        \"\"\"\n        return len(self) &gt; 0\n\n    @property\n    def length(self) -&gt; int:\n        \"\"\"Get the number of elements in the list.\n\n        Returns\n        -------\n        int\n            Number of elements\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3]).length\n        3\n        \"\"\"\n        return len(self)\n\n    @property\n    def last_option(self) -&gt; Optional[A]:\n        \"\"\"Get the last element if it exists.\n\n        Returns\n        -------\n        Optional[A]\n            Last element, or None if list is empty\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3]).last_option\n        3\n        &gt;&gt;&gt; Slist([]).last_option\n        None\n        \"\"\"\n        try:\n            return self.__getitem__(-1)\n        except IndexError:\n            return None\n\n    @property\n    def first_option(self) -&gt; Optional[A]:\n        \"\"\"Get the first element if it exists.\n\n        Returns\n        -------\n        Optional[A]\n            First element, or None if list is empty\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3]).first_option\n        1\n        &gt;&gt;&gt; Slist([]).first_option\n        None\n        \"\"\"\n        try:\n            return self.__getitem__(0)\n        except IndexError:\n            return None\n\n    @property\n    def mode_option(self) -&gt; Optional[A]:\n        \"\"\"Get the most common element if it exists.\n\n        Returns\n        -------\n        Optional[A]\n            Most frequent element, or None if list is empty or has no unique mode\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 2, 3]).mode_option\n        2\n        &gt;&gt;&gt; Slist([1, 1, 2, 2]).mode_option  # No unique mode\n        None\n        &gt;&gt;&gt; Slist([]).mode_option\n        None\n        \"\"\"\n        try:\n            return statistics.mode(self)\n        except statistics.StatisticsError:\n            return None\n\n    def mode_or_raise(self, exception: Exception = RuntimeError(\"List is empty\")) -&gt; A:\n        \"\"\"Get the most common element or raise an exception.\n\n        Parameters\n        ----------\n        exception : Exception, optional\n            Exception to raise if no mode exists, by default RuntimeError(\"List is empty\")\n\n        Returns\n        -------\n        A\n            Most frequent element\n\n        Raises\n        ------\n        Exception\n            If list is empty or has no unique mode\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 2, 3]).mode_or_raise()\n        2\n        &gt;&gt;&gt; try:\n        ...     Slist([]).mode_or_raise()\n        ... except RuntimeError as e:\n        ...     print(str(e))\n        List is empty\n        \"\"\"\n        try:\n            return statistics.mode(self)\n        except statistics.StatisticsError:\n            raise exception\n\n    def first_or_raise(self, exception: Exception = RuntimeError(\"List is empty\")) -&gt; A:\n        \"\"\"Get the first element or raise an exception.\n\n        Parameters\n        ----------\n        exception : Exception, optional\n            Exception to raise if list is empty, by default RuntimeError(\"List is empty\")\n\n        Returns\n        -------\n        A\n            First element\n\n        Raises\n        ------\n        Exception\n            If list is empty\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3]).first_or_raise()\n        1\n        &gt;&gt;&gt; try:\n        ...     Slist([]).first_or_raise()\n        ... except RuntimeError as e:\n        ...     print(str(e))\n        List is empty\n        \"\"\"\n        try:\n            return self.__getitem__(0)\n        except IndexError:\n            raise exception\n\n    def last_or_raise(self, exception: Exception = RuntimeError(\"List is empty\")) -&gt; A:\n        \"\"\"Get the last element or raise an exception.\n\n        Parameters\n        ----------\n        exception : Exception, optional\n            Exception to raise if list is empty, by default RuntimeError(\"List is empty\")\n\n        Returns\n        -------\n        A\n            Last element\n\n        Raises\n        ------\n        Exception\n            If list is empty\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3]).last_or_raise()\n        3\n        &gt;&gt;&gt; try:\n        ...     Slist([]).last_or_raise()\n        ... except RuntimeError as e:\n        ...     print(str(e))\n        List is empty\n        \"\"\"\n        try:\n            return self.__getitem__(-1)\n        except IndexError:\n            raise exception\n\n    def find_one(self, predicate: Callable[[A], bool]) -&gt; Optional[A]:\n        \"\"\"Find first element that satisfies a predicate.\n\n        Parameters\n        ----------\n        predicate : Callable[[A], bool]\n            Function that returns True for the desired element\n\n        Returns\n        -------\n        Optional[A]\n            First matching element, or None if no match found\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3, 4]).find_one(lambda x: x &gt; 2)\n        3\n        &gt;&gt;&gt; Slist([1, 2, 3]).find_one(lambda x: x &gt; 5)\n        None\n        \"\"\"\n        for item in self:\n            if predicate(item):\n                return item\n        return None\n\n    def find_one_idx(self, predicate: Callable[[A], bool]) -&gt; Optional[int]:\n        \"\"\"Find index of first element that satisfies a predicate.\n\n        Parameters\n        ----------\n        predicate : Callable[[A], bool]\n            Function that returns True for the desired element\n\n        Returns\n        -------\n        Optional[int]\n            Index of first matching element, or None if no match found\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3, 4]).find_one_idx(lambda x: x &gt; 2)\n        2\n        &gt;&gt;&gt; Slist([1, 2, 3]).find_one_idx(lambda x: x &gt; 5)\n        None\n        \"\"\"\n        for idx, item in enumerate(self):\n            if predicate(item):\n                return idx\n        return None\n\n    def find_last_idx(self, predicate: Callable[[A], bool]) -&gt; Optional[int]:\n        \"\"\"Find index of last element that satisfies a predicate.\n\n        Parameters\n        ----------\n        predicate : Callable[[A], bool]\n            Function that returns True for the desired element\n\n        Returns\n        -------\n        Optional[int]\n            Index of last matching element, or None if no match found\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3, 2, 1]).find_last_idx(lambda x: x == 2)\n        3\n        &gt;&gt;&gt; Slist([1, 2, 3]).find_last_idx(lambda x: x &gt; 5)\n        None\n        \"\"\"\n        indexes = []\n        for idx, item in enumerate(self):\n            if predicate(item):\n                indexes.append(idx)\n        return indexes[-1] if indexes else None\n\n    def find_one_idx_or_raise(\n        self,\n        predicate: Callable[[A], bool],\n        exception: Exception = RuntimeError(\"Failed to find predicate\"),\n    ) -&gt; int:\n        \"\"\"Find index of first element that satisfies a predicate or raise exception.\n\n        Parameters\n        ----------\n        predicate : Callable[[A], bool]\n            Function that returns True for the desired element\n        exception : Exception, optional\n            Exception to raise if no match found, by default RuntimeError(\"Failed to find predicate\")\n\n        Returns\n        -------\n        int\n            Index of first matching element\n\n        Raises\n        ------\n        Exception\n            If no matching element is found\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3, 4]).find_one_idx_or_raise(lambda x: x &gt; 2)\n        2\n        &gt;&gt;&gt; try:\n        ...     Slist([1, 2, 3]).find_one_idx_or_raise(lambda x: x &gt; 5)\n        ... except RuntimeError as e:\n        ...     print(str(e))\n        Failed to find predicate\n        \"\"\"\n        result = self.find_one_idx(predicate=predicate)\n        if result is not None:\n            return result\n        else:\n            raise exception\n\n    def find_last_idx_or_raise(\n        self,\n        predicate: Callable[[A], bool],\n        exception: Exception = RuntimeError(\"Failed to find predicate\"),\n    ) -&gt; int:\n        \"\"\"Find index of last element that satisfies a predicate or raise exception.\n\n        Parameters\n        ----------\n        predicate : Callable[[A], bool]\n            Function that returns True for the desired element\n        exception : Exception, optional\n            Exception to raise if no match found, by default RuntimeError(\"Failed to find predicate\")\n\n        Returns\n        -------\n        int\n            Index of last matching element\n\n        Raises\n        ------\n        Exception\n            If no matching element is found\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3, 2, 1]).find_last_idx_or_raise(lambda x: x == 2)\n        3\n        &gt;&gt;&gt; try:\n        ...     Slist([1, 2, 3]).find_last_idx_or_raise(lambda x: x &gt; 5)\n        ... except RuntimeError as e:\n        ...     print(str(e))\n        Failed to find predicate\n        \"\"\"\n        result = self.find_last_idx(predicate=predicate)\n        if result is not None:\n            return result\n        else:\n            raise exception\n\n    def take(self, n: int) -&gt; Slist[A]:\n        return Slist(self[:n])\n\n    def take_or_raise(self, n: int) -&gt; Slist[A]:\n        # raises if we end up having less elements than n\n        if len(self) &lt; n:\n            raise ValueError(f\"Cannot take {n} elements from a list of length {len(self)}\")\n        return Slist(self[:n])\n\n    def take_until_exclusive(self, predicate: Callable[[A], bool]) -&gt; Slist[A]:\n        \"\"\"Takes the first elements until the predicate is true.\n        Does not include the element that caused the predicate to return true.\"\"\"\n        new: Slist[A] = Slist()\n        for x in self:\n            if predicate(x):\n                break\n            else:\n                new.append(x)\n        return new\n\n    def take_until_inclusive(self, predicate: Callable[[A], bool]) -&gt; Slist[A]:\n        \"\"\"Takes the first elements until the predicate is true.\n        Includes the element that caused the predicate to return true.\"\"\"\n        new: Slist[A] = Slist()\n        for x in self:\n            if predicate(x):\n                new.append(x)\n                break\n            else:\n                new.append(x)\n        return new\n\n    def sort_by(self, key: Callable[[A], CanCompare], reverse: bool = False) -&gt; Slist[A]:\n        new = self.copy()\n        return Slist(sorted(new, key=key, reverse=reverse))\n\n    def percentile_by(self, key: Callable[[A], CanCompare], percentile: float) -&gt; A:\n        \"\"\"Gets the element at the given percentile\"\"\"\n        if percentile &lt; 0 or percentile &gt; 1:\n            raise ValueError(f\"Percentile must be between 0 and 1. Got {percentile}\")\n        if self.length == 0:\n            raise ValueError(\"Cannot get percentile of empty list\")\n        result = self.sort_by(key).get(int(len(self) * percentile), None)\n        assert result is not None\n        return result\n\n    def median_by(self, key: Callable[[A], CanCompare]) -&gt; A:\n        \"\"\"Gets the median element\"\"\"\n        if self.length == 0:\n            raise ValueError(\"Cannot get median of empty list\")\n        return self.percentile_by(key, 0.5)\n\n    def sorted(self: Slist[CanCompare], reverse: bool = False) -&gt; Slist[CanCompare]:\n        return self.sort_by(key=identity, reverse=reverse)\n\n    def reversed(self) -&gt; Slist[A]:\n        \"\"\"Returns a new list with the elements in reversed order\"\"\"\n        return Slist(reversed(self))\n\n    def sort_by_penalise_duplicates(\n        self,\n        sort_key: Callable[[A], CanCompare],\n        duplicate_key: Callable[[A], CanHash],\n        reverse: bool = False,\n    ) -&gt; Slist[A]:\n        \"\"\"Sort on a given sort key, but penalises duplicate_key such that they will be at the back of the list\n        # &gt;&gt;&gt; Slist([6, 5, 4, 3, 2, 1, 1, 1]).sort_by_penalise_duplicates(sort_key=identity, duplicate_key=identity)\n        [1, 2, 3, 4, 5, 6, 1, 1]\n        \"\"\"\n        non_dupes = Slist[A]()\n        dupes = Slist[A]()\n\n        dupes_tracker: set[CanHash] = set()\n        for item in self:\n            dupe_key = duplicate_key(item)\n            if dupe_key in dupes_tracker:\n                dupes.append(item)\n            else:\n                non_dupes.append(item)\n                dupes_tracker.add(dupe_key)\n\n        return non_dupes.sort_by(key=sort_key, reverse=reverse) + dupes.sort_by(key=sort_key, reverse=reverse)\n\n    def shuffle_with_penalise_duplicates(\n        self,\n        duplicate_key: Callable[[A], CanHash],\n        seed: Optional[str] = None,\n    ) -&gt; Slist[A]:\n        \"\"\"Shuffle, but penalises duplicate_key such that they will be at the back of the list\n        # &gt;&gt;&gt; Slist([6, 5, 4, 3, 2, 2, 1, 1, 1]).shuffle_by_penalise_duplicates(duplicate_key=identity)\n        [6, 4, 1, 3, 5, 2, 1, 2, 1]\n        \"\"\"\n        non_dupes = Slist[A]()\n        dupes = Slist[A]()\n        shuffled = self.shuffle(seed)\n\n        dupes_tracker: set[CanHash] = set()\n        for item in shuffled:\n            dupe_key = duplicate_key(item)\n            if dupe_key in dupes_tracker:\n                dupes.append(item)\n            else:\n                non_dupes.append(item)\n                dupes_tracker.add(dupe_key)\n\n        return non_dupes.shuffle(seed) + dupes.shuffle(seed)\n\n    def __add__(self, other: Sequence[B]) -&gt; Slist[Union[A, B]]:  # type: ignore\n        return Slist(super().__add__(other))  # type: ignore\n\n    def add(self, other: Sequence[B]) -&gt; Slist[Union[A, B]]:\n        return self + other\n\n    def add_one(self, other: B) -&gt; Slist[Union[A, B]]:\n        new: Slist[Union[A, B]] = self.copy()  # type: ignore\n        new.append(other)\n        return new\n\n    @overload  # type: ignore\n    def __getitem__(self, i: int) -&gt; A:\n        pass\n\n    @overload\n    def __getitem__(self, i: slice) -&gt; Slist[A]:\n        pass\n\n    def __getitem__(self, i: Union[int, slice]) -&gt; Union[A, Slist[A]]:  # type: ignore\n        if isinstance(i, int):\n            return super().__getitem__(i)\n        else:\n            return Slist(super(Slist, self).__getitem__(i))\n\n    def grouped(self, size: int) -&gt; Slist[Slist[A]]:\n        \"\"\"Groups the list into chunks of size `size`\"\"\"\n        output: Slist[Slist[A]] = Slist()\n        for i in range(0, self.length, size):\n            output.append(self[i : i + size])\n        return output\n\n    def window(self, size: int) -&gt; Slist[Slist[A]]:\n        \"\"\"Returns a list of windows of size `size`\n        If the list is too small or empty, returns an empty list\n        Example:\n        &gt;&gt;&gt; Slist([1, 2, 3, 4, 5]).window(3)\n        [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\n\n        &gt;&gt;&gt; Slist([1]).window(2)\n        []\n        \"\"\"\n        output: Slist[Slist[A]] = Slist()\n        for i in range(0, self.length - size + 1):\n            output.append(self[i : i + size])\n        return output\n\n    def distinct(self: Sequence[CanHash]) -&gt; Slist[CanHash]:\n        \"\"\"Remove duplicate elements while preserving order.\n\n        Returns\n        -------\n        Slist[CanHash]\n            A new list with duplicates removed, maintaining original order\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 2, 3, 1, 4]).distinct()\n        Slist([1, 2, 3, 4])\n        \"\"\"\n        seen = set()\n        output = Slist[CanHash]()\n        for item in self:\n            if item in seen:\n                continue\n            else:\n                seen.add(item)\n                output.append(item)\n        return output\n\n    def distinct_by(self, key: Callable[[A], CanHash]) -&gt; Slist[A]:\n        \"\"\"Remove duplicates based on a key function while preserving order.\n\n        Parameters\n        ----------\n        key : Callable[[A], CanHash]\n            Function to compute the unique key for each element\n\n        Returns\n        -------\n        Slist[A]\n            A new list with duplicates removed, maintaining original order\n\n        Examples\n        --------\n        &gt;&gt;&gt; data = Slist([(1, 'a'), (2, 'b'), (1, 'c')])\n        &gt;&gt;&gt; data.distinct_by(lambda x: x[0])  # Distinct by first element\n        Slist([(1, 'a'), (2, 'b')])\n        \"\"\"\n        seen = set()\n        output = Slist[A]()\n        for item in self:\n            item_hash = key(item)\n            if item_hash in seen:\n                continue\n            else:\n                seen.add(item_hash)\n                output.append(item)\n        return output\n\n    def distinct_item_or_raise(self, key: Callable[[A], CanHash]) -&gt; A:\n        \"\"\"Get the single unique item by a key function.\n\n        Raises ValueError if the list is empty or contains multiple distinct items.\n\n        Parameters\n        ----------\n        key : Callable[[A], CanHash]\n            Function to compute the unique key for each element\n\n        Returns\n        -------\n        A\n            The single unique item\n\n        Raises\n        ------\n        ValueError\n            If the list is empty or contains multiple distinct items\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 1, 1]).distinct_item_or_raise(lambda x: x)\n        1\n        &gt;&gt;&gt; try:\n        ...     Slist([1, 2, 1]).distinct_item_or_raise(lambda x: x)\n        ... except ValueError as e:\n        ...     print(str(e))\n        Slist is not distinct [1, 2, 1]\n        \"\"\"\n        if not self:\n            raise ValueError(\"Slist is empty\")\n        distinct = self.distinct_by(key)\n        if len(distinct) != 1:\n            raise ValueError(f\"Slist is not distinct {self}\")\n        return distinct[0]\n\n    def par_map(self, func: Callable[[A], B], executor: concurrent.futures.Executor) -&gt; Slist[B]:\n        \"\"\"Apply a function to each element in parallel using an executor.\n\n        Parameters\n        ----------\n        func : Callable[[A], B]\n            Function to apply to each element. Must be picklable if using ProcessPoolExecutor\n        executor : concurrent.futures.Executor\n            The executor to use for parallel execution\n\n        Returns\n        -------\n        Slist[B]\n            A new list with the results of applying func to each element\n\n        Examples\n        --------\n        &gt;&gt;&gt; from concurrent.futures import ThreadPoolExecutor\n        &gt;&gt;&gt; with ThreadPoolExecutor() as exe:\n        ...     Slist([1, 2, 3]).par_map(lambda x: x * 2, exe)\n        Slist([2, 4, 6])\n\n        Notes\n        -----\n        If using ProcessPoolExecutor, the function must be picklable (e.g., no lambda functions)\n        \"\"\"\n        futures: List[concurrent.futures._base.Future[B]] = [executor.submit(func, item) for item in self]\n        results = []\n        for fut in futures:\n            results.append(fut.result())\n        return Slist(results)\n\n    async def par_map_async(\n        self, func: Callable[[A], typing.Awaitable[B]], max_par: int | None = None, tqdm: bool = False\n    ) -&gt; Slist[B]:\n        \"\"\"Asynchronously apply a function to each element with optional parallelism limit.\n\n        Parameters\n        ----------\n        func : Callable[[A], Awaitable[B]]\n            Async function to apply to each element\n        max_par : int | None, optional\n            Maximum number of parallel operations, by default None\n        tqdm : bool, optional\n            Whether to show a progress bar, by default False\n\n        Returns\n        -------\n        Slist[B]\n            A new Slist with the transformed elements\n\n        Examples\n        --------\n        &gt;&gt;&gt; async def slow_double(x):\n        ...     await asyncio.sleep(0.1)\n        ...     return x * 2\n        &gt;&gt;&gt; await Slist([1, 2, 3]).par_map_async(slow_double, max_par=2)\n        Slist([2, 4, 6])\n        \"\"\"\n        if max_par is None:\n            if tqdm:\n                import tqdm as tqdm_module\n\n                tqdm_counter = tqdm_module.tqdm(total=len(self))\n\n                async def func_with_tqdm(item: A) -&gt; B:\n                    result = await func(item)\n                    tqdm_counter.update(1)\n                    return result\n\n                return Slist(await asyncio.gather(*[func_with_tqdm(item) for item in self]))\n            else:\n                # todo: clean up branching\n                return Slist(await asyncio.gather(*[func(item) for item in self]))\n\n        else:\n            assert max_par &gt; 0, \"max_par must be greater than 0\"\n            sema = asyncio.Semaphore(max_par)\n            if tqdm:\n                import tqdm as tqdm_module\n\n                tqdm_counter = tqdm_module.tqdm(total=len(self))\n\n                async def func_with_semaphore(item: A) -&gt; B:\n                    async with sema:\n                        result = await func(item)\n                        tqdm_counter.update(1)\n                        return result\n\n            else:\n\n                async def func_with_semaphore(item: A) -&gt; B:\n                    async with sema:\n                        return await func(item)\n\n            return Slist(await asyncio.gather(*[func_with_semaphore(item) for item in self]))\n\n    async def gather(self: Sequence[typing.Awaitable[B]]) -&gt; Slist[B]:\n        \"\"\"Gather and await all awaitables in the sequence.\n\n        Returns\n        -------\n        Slist[B]\n            A new Slist containing the awaited results\n\n        Examples\n        --------\n        &gt;&gt;&gt; async def slow_value(x):\n        ...     await asyncio.sleep(0.1)\n        ...     return x\n        &gt;&gt;&gt; awaitables = [slow_value(1), slow_value(2), slow_value(3)]\n        &gt;&gt;&gt; await Slist(awaitables).gather()\n        Slist([1, 2, 3])\n        \"\"\"\n        return Slist(await asyncio.gather(*self))\n\n    def filter_text_search(self, key: Callable[[A], str], search: List[str]) -&gt; Slist[A]:\n        \"\"\"Filter items based on text search terms.\n\n        Parameters\n        ----------\n        key : Callable[[A], str]\n            Function to extract searchable text from each item\n        search : List[str]\n            List of search terms to match (case-insensitive)\n\n        Returns\n        -------\n        Slist[A]\n            Items where key text matches any search term\n\n        Examples\n        --------\n        &gt;&gt;&gt; items = Slist(['apple pie', 'banana bread', 'cherry cake'])\n        &gt;&gt;&gt; items.filter_text_search(lambda x: x, ['pie', 'cake'])\n        Slist(['apple pie', 'cherry cake'])\n        \"\"\"\n\n        def matches_search(text: str) -&gt; bool:\n            if search:\n                search_regex = re.compile(\"|\".join(search), re.IGNORECASE)\n                return bool(re.search(search_regex, text))\n            else:\n                return True  # No filter if search undefined\n\n        return self.filter(predicate=lambda item: matches_search(key(item)))\n\n    def mk_string(self: Sequence[str], sep: str) -&gt; str:\n        \"\"\"Join string elements with a separator.\n\n        Parameters\n        ----------\n        sep : str\n            Separator to use between elements\n\n        Returns\n        -------\n        str\n            Joined string\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist(['a', 'b', 'c']).mk_string(', ')\n        'a, b, c'\n        \"\"\"\n        return sep.join(self)\n\n    @overload\n    def sum(self: Sequence[int]) -&gt; int: ...\n\n    @overload\n    def sum(self: Sequence[float]) -&gt; float: ...\n\n    def sum(\n        self: Sequence[Union[int, float, bool]],\n    ) -&gt; Union[int, float]:\n        \"\"\"Returns 0 when the list is empty\"\"\"\n        return sum(self)\n\n    def average(\n        self: Sequence[Union[int, float, bool]],\n    ) -&gt; Optional[float]:\n        \"\"\"Calculate the arithmetic mean of numeric values.\n\n        Returns\n        -------\n        Optional[float]\n            The average of all values, or None if the list is empty\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3, 4]).average()\n        2.5\n        &gt;&gt;&gt; Slist([]).average()\n        None\n        \"\"\"\n        this = typing.cast(Slist[Union[int, float, bool]], self)\n        return this.sum() / this.length if this.length &gt; 0 else None\n\n    def average_or_raise(\n        self: Sequence[Union[int, float, bool]],\n    ) -&gt; float:\n        \"\"\"Calculate the arithmetic mean of numeric values.\n\n        Returns\n        -------\n        float\n            The average of all values\n\n        Raises\n        ------\n        ValueError\n            If the list is empty\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3, 4]).average_or_raise()\n        2.5\n        &gt;&gt;&gt; try:\n        ...     Slist([]).average_or_raise()\n        ... except ValueError as e:\n        ...     print(str(e))\n        Cannot get average of empty list\n        \"\"\"\n        this = typing.cast(Slist[Union[int, float, bool]], self)\n        if this.length == 0:\n            raise ValueError(\"Cannot get average of empty list\")\n        return this.sum() / this.length\n\n    def statistics_or_raise(\n        self: Sequence[Union[int, float, bool]],\n    ) -&gt; AverageStats:\n        \"\"\"Calculate comprehensive statistics for numeric values.\n\n        Returns\n        -------\n        AverageStats\n            Statistics including mean, standard deviation, and confidence intervals\n\n        Raises\n        ------\n        ValueError\n            If the list is empty\n\n        Examples\n        --------\n        &gt;&gt;&gt; stats = Slist([1, 2, 3, 4, 5]).statistics_or_raise()\n        &gt;&gt;&gt; round(stats.average, 2)\n        3.0\n        &gt;&gt;&gt; round(stats.standard_deviation, 2)\n        1.58\n        \"\"\"\n        this = typing.cast(Slist[Union[int, float, bool]], self)\n        if this.length == 0:\n            raise ValueError(\"Cannot get average of empty list\")\n        average = this.average_or_raise()\n        standard_deviation = this.standard_deviation()\n        assert standard_deviation is not None\n        standard_error = standard_deviation / ((this.length) ** 0.5)\n        upper_ci = average + 1.96 * standard_error\n        lower_ci = average - 1.96 * standard_error\n        average_plus_minus_95 = 1.96 * standard_error\n        return AverageStats(\n            average=average,\n            standard_deviation=standard_deviation,\n            upper_confidence_interval_95=upper_ci,\n            lower_confidence_interval_95=lower_ci,\n            count=this.length,\n            average_plus_minus_95=average_plus_minus_95,\n        )\n\n    def standard_deviation(self: Slist[Union[int, float]]) -&gt; Optional[float]:\n        \"\"\"Calculate the population standard deviation.\n\n        Returns\n        -------\n        Optional[float]\n            The standard deviation, or None if the list is empty\n\n        Examples\n        --------\n        &gt;&gt;&gt; round(Slist([1, 2, 3, 4, 5]).standard_deviation(), 2)\n        1.58\n        &gt;&gt;&gt; Slist([]).standard_deviation()\n        None\n        \"\"\"\n        return statistics.stdev(self) if self.length &gt; 0 else None\n\n    def standardize(self: Slist[Union[int, float]]) -&gt; Slist[float]:\n        \"\"\"Standardize values to have mean 0 and standard deviation 1.\n\n        Returns\n        -------\n        Slist[float]\n            Standardized values, or empty list if input is empty\n\n        Examples\n        --------\n        &gt;&gt;&gt; result = Slist([1, 2, 3, 4, 5]).standardize()\n        &gt;&gt;&gt; [round(x, 2) for x in result]  # Rounded for display\n        [-1.26, -0.63, 0.0, 0.63, 1.26]\n        \"\"\"\n        mean = self.average()\n        sd = self.standard_deviation()\n        return Slist((x - mean) / sd for x in self) if mean is not None and sd is not None else Slist()\n\n    def fold_left(self, acc: B, func: Callable[[B, A], B]) -&gt; B:\n        \"\"\"Fold left operation (reduce) with initial accumulator.\n\n        Parameters\n        ----------\n        acc : B\n            Initial accumulator value\n        func : Callable[[B, A], B]\n            Function to combine accumulator with each element\n\n        Returns\n        -------\n        B\n            Final accumulated value\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3, 4]).fold_left(0, lambda acc, x: acc + x)\n        10\n        &gt;&gt;&gt; Slist(['a', 'b', 'c']).fold_left('', lambda acc, x: acc + x)\n        'abc'\n        \"\"\"\n        return reduce(func, self, acc)\n\n    def fold_right(self, acc: B, func: Callable[[A, B], B]) -&gt; B:\n        \"\"\"Fold right operation with initial accumulator.\n\n        Parameters\n        ----------\n        acc : B\n            Initial accumulator value\n        func : Callable[[A, B], B]\n            Function to combine each element with accumulator\n\n        Returns\n        -------\n        B\n            Final accumulated value\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3]).fold_right('', lambda x, acc: str(x) + acc)\n        '321'\n        \"\"\"\n        return reduce(lambda a, b: func(b, a), reversed(self), acc)\n\n    def sum_option(self: Sequence[CanAdd]) -&gt; Optional[CanAdd]:\n        \"\"\"Sums the elements of the sequence. Returns None if the sequence is empty.\n\n        Returns\n        -------\n        Optional[CanAdd]\n            The sum of all elements in the sequence, or None if the sequence is empty\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3]).sum_option()\n        6\n        &gt;&gt;&gt; Slist([]).sum_option()\n        None\n        \"\"\"\n        return reduce(lambda a, b: a + b, self) if len(self) &gt; 0 else None\n\n    def sum_or_raise(self: Sequence[CanAdd]) -&gt; CanAdd:\n        \"\"\"Sums the elements of the sequence. Raises an error if the sequence is empty.\n\n        Returns\n        -------\n        CanAdd\n            The sum of all elements in the sequence\n\n        Raises\n        ------\n        AssertionError\n            If the sequence is empty\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3]).sum_or_raise()\n        6\n        &gt;&gt;&gt; Slist([]).sum_or_raise()  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        AssertionError: Cannot fold empty list\n        \"\"\"\n        assert len(self) &gt; 0, \"Cannot fold empty list\"\n        return reduce(lambda a, b: a + b, self)\n\n    def split_by(self, predicate: Callable[[A], bool]) -&gt; Tuple[Slist[A], Slist[A]]:\n        \"\"\"Split list into two lists based on a predicate. Left list contains items that match the predicate.\n\n        Parameters\n        ----------\n        predicate : Callable[[A], bool]\n            Function to determine which list each element goes into\n\n        Returns\n        -------\n        Tuple[Slist[A], Slist[A]]\n            Tuple of (matching elements, non-matching elements)\n\n        Examples\n        --------\n        &gt;&gt;&gt; evens, odds = Slist([1, 2, 3, 4, 5]).split_by(lambda x: x % 2 == 0)\n        &gt;&gt;&gt; evens\n        Slist([2, 4])\n        &gt;&gt;&gt; odds\n        Slist([1, 3, 5])\n        \"\"\"\n        left = Slist[A]()\n        right = Slist[A]()\n        for item in self:\n            if predicate(item):\n                left.append(item)\n            else:\n                right.append(item)\n        return left, right\n\n    def split_on(self, predicate: Callable[[A], bool]) -&gt; Slist[Slist[A]]:\n        \"\"\"Split list into sublists based on a predicate.\n\n        Returns\n        -------\n        Slist[Slist[A]]\n            List of sublists\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3, 4, 5]).split_on(lambda x: x % 2 == 0)\n        Slist([Slist([1, 3, 5]), Slist([2, 4])])\n        \"\"\"\n        output: Slist[Slist[A]] = Slist()\n        current = Slist[A]()\n        for item in self:\n            if predicate(item):\n                output.append(current)\n                current = Slist[A]()\n            else:\n                current.append(item)\n        output.append(current)\n        return output\n\n    def split_proportion(self, left_proportion: float) -&gt; Tuple[Slist[A], Slist[A]]:\n        \"\"\"Split list into two parts based on a proportion.\n\n        Parameters\n        ----------\n        left_proportion : float\n            Proportion of elements to include in first list (0 &lt; left_proportion &lt; 1)\n\n        Returns\n        -------\n        Tuple[Slist[A], Slist[A]]\n            Tuple of (first part, second part)\n\n        Examples\n        --------\n        &gt;&gt;&gt; first, second = Slist([1, 2, 3, 4, 5]).split_proportion(0.6)\n        &gt;&gt;&gt; first\n        Slist([1, 2, 3])\n        &gt;&gt;&gt; second\n        Slist([4, 5])\n        \"\"\"\n        assert 0 &lt; left_proportion &lt; 1, \"left_proportion needs to be between 0 and 1\"\n        left = Slist[A]()\n        right = Slist[A]()\n        for idx, item in enumerate(self):\n            if idx &lt; len(self) * left_proportion:\n                left.append(item)\n            else:\n                right.append(item)\n        return left, right\n\n    def split_into_n(self, n: int) -&gt; Slist[Slist[A]]:\n        \"\"\"Split list into n roughly equal parts.\n\n        Parameters\n        ----------\n        n : int\n            Number of parts to split into (must be positive)\n\n        Returns\n        -------\n        Slist[Slist[A]]\n            List of n sublists of roughly equal size\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3, 4, 5]).split_into_n(2)\n        Slist([Slist([1, 3, 5]), Slist([2, 4])])\n        \"\"\"\n        assert n &gt; 0, \"n needs to be greater than 0\"\n        output: Slist[Slist[A]] = Slist()\n        for _ in range(n):\n            output.append(Slist[A]())\n        for idx, item in enumerate(self):\n            output[idx % n].append(item)\n        return output\n\n    def copy(self) -&gt; Slist[A]:\n        \"\"\"Create a shallow copy of the list.\n\n        Returns\n        -------\n        Slist[A]\n            A new Slist with the same elements\n\n        Examples\n        --------\n        &gt;&gt;&gt; original = Slist([1, 2, 3])\n        &gt;&gt;&gt; copied = original.copy()\n        &gt;&gt;&gt; copied.append(4)\n        &gt;&gt;&gt; original  # Original is unchanged\n        Slist([1, 2, 3])\n        \"\"\"\n        return Slist(super().copy())\n\n    def repeat_until_size(self, size: int) -&gt; Optional[Slist[A]]:\n        \"\"\"Repeat the list elements until reaching specified size.\n\n        Parameters\n        ----------\n        size : int\n            Target size (must be positive)\n\n        Returns\n        -------\n        Optional[Slist[A]]\n            New list with repeated elements, or None if input is empty\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2]).repeat_until_size(5)\n        Slist([1, 2, 1, 2, 1])\n        &gt;&gt;&gt; Slist([]).repeat_until_size(3)\n        None\n        \"\"\"\n        assert size &gt; 0, \"size needs to be greater than 0\"\n        if self.is_empty:\n            return None\n        else:\n            new = Slist[A]()\n            while True:\n                for item in self:\n                    if len(new) &gt;= size:\n                        return new\n                    else:\n                        new.append(item)\n\n    def repeat_until_size_enumerate(self, size: int) -&gt; Slist[Tuple[int, A]]:\n        \"\"\"Repeat the list elements until reaching specified size, with enumeration.\n\n        Parameters\n        ----------\n        size : int\n            Target size (must be positive)\n\n        Returns\n        -------\n        Slist[Tuple[int, A]]\n            New list with repeated elements and their repetition count\n\n        Raises\n        ------\n        AssertionError\n            If size is not positive\n        ValueError\n            If input list is empty\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([\"a\", \"b\"]).repeat_until_size_enumerate(5)\n        Slist([(0, 'a'), (0, 'b'), (1, 'a'), (1, 'b'), (2, 'a')])\n        \"\"\"\n        assert size &gt; 0, \"size needs to be greater than 0\"\n        if self.is_empty:\n            raise ValueError(\"input needs to be non empty\")\n\n        new = Slist[Tuple[int, A]]()\n        repetition_count = 0\n\n        while True:\n            for item in self:\n                if len(new) &gt;= size:\n                    return new\n                else:\n                    new.append((repetition_count, item))\n            repetition_count += 1\n\n    def repeat_until_size_or_raise(self, size: int) -&gt; Slist[A]:\n        \"\"\"Repeat the list elements until reaching specified size.\n\n        Parameters\n        ----------\n        size : int\n            Target size (must be positive)\n\n        Returns\n        -------\n        Slist[A]\n            New list with repeated elements\n\n        Raises\n        ------\n        AssertionError\n            If size is not positive\n        ValueError\n            If input list is empty\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2]).repeat_until_size_or_raise(5)\n        Slist([1, 2, 1, 2, 1])\n        \"\"\"\n        assert size &gt; 0, \"size needs to be greater than 0\"\n        assert not self.is_empty, \"input needs to be non empty\"\n        new = Slist[A]()\n        while True:\n            for item in self:\n                if len(new) &gt;= size:\n                    return new\n                else:\n                    new.append(item)\n\n    @overload\n    def zip(self, other: Sequence[B], /) -&gt; Slist[Tuple[A, B]]: ...\n\n    @overload\n    def zip(self, other1: Sequence[B], other2: Sequence[C], /) -&gt; Slist[Tuple[A, B, C]]: ...\n\n    @overload\n    def zip(self, other1: Sequence[B], other2: Sequence[C], other3: Sequence[D], /) -&gt; Slist[Tuple[A, B, C, D]]: ...\n\n    @overload\n    def zip(\n        self, other1: Sequence[B], other2: Sequence[C], other3: Sequence[D], other4: Sequence[E], /\n    ) -&gt; Slist[Tuple[A, B, C, D, E]]: ...\n\n    def zip(self: Sequence[A], *others: Sequence[Any]) -&gt; Slist[Tuple[Any, ...]]:\n        \"\"\"Zip this list with other sequences.\n\n        Parameters\n        ----------\n        *others : Sequence[B]\n            Other sequences to zip with\n\n        Returns\n        -------\n        Slist[Tuple[A, *Tuple[B, ...]]]\n            List of tuples containing elements from all sequences\n\n        Raises\n        ------\n        TypeError\n            If sequences have different lengths\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3]).zip(Slist([\"1\", \"2\", \"3\"]))\n        Slist([(1, \"1\"), (2, \"2\"), (3, \"3\")])\n        &gt;&gt;&gt; Slist([1, 2, 3]).zip(Slist([\"1\", \"2\", \"3\"]), Slist([True, True, True]))\n        Slist([(1, \"1\", True), (2, \"2\", True), (3, \"3\", True)])\n        \"\"\"\n        # Convert to list to check lengths\n        if sys.version_info &gt;= (3, 10):\n            return Slist(zip(self, *others, strict=True))\n        else:\n            return Slist(zip(self, *others))\n\n    @overload\n    def zip_cycle(self, other: Sequence[B], /) -&gt; Slist[Tuple[A, B]]: ...\n\n    @overload\n    def zip_cycle(self, other1: Sequence[B], other2: Sequence[C], /) -&gt; Slist[Tuple[A, B, C]]: ...\n\n    @overload\n    def zip_cycle(\n        self, other1: Sequence[B], other2: Sequence[C], other3: Sequence[D], /\n    ) -&gt; Slist[Tuple[A, B, C, D]]: ...\n\n    @overload\n    def zip_cycle(\n        self, other1: Sequence[B], other2: Sequence[C], other3: Sequence[D], other4: Sequence[E], /\n    ) -&gt; Slist[Tuple[A, B, C, D, E]]: ...\n\n    def zip_cycle(self: Sequence[A], *others: Sequence[Any]) -&gt; Slist[Tuple[Any, ...]]:\n        \"\"\"Zip sequences by cycling shorter ones until all are exhausted.\n\n        Unlike regular zip which stops at the shortest sequence, zip_cycle\n        repeats shorter sequences cyclically until the longest sequence is exhausted.\n\n        Parameters\n        ----------\n        *others : Sequence[Any]\n            Other sequences to zip with\n\n        Returns\n        -------\n        Slist[Tuple[Any, ...]]\n            List of tuples containing elements from all sequences\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3]).zip_cycle(['a', 'b'])\n        Slist([(1, 'a'), (2, 'b'), (3, 'a')])\n        &gt;&gt;&gt; Slist([1, 2]).zip_cycle(['a', 'b', 'c', 'd'])\n        Slist([(1, 'a'), (2, 'b'), (1, 'c'), (2, 'd')])\n        &gt;&gt;&gt; Slist([1, 2, 3]).zip_cycle(['a', 'b'], [10, 20, 30, 40])\n        Slist([(1, 'a', 10), (2, 'b', 20), (3, 'a', 30), (1, 'b', 40)])\n        \"\"\"\n        all_sequences = [self] + list(others)\n\n        # If any sequence is empty, return empty list\n        if any(len(seq) == 0 for seq in all_sequences):\n            return Slist()\n\n        # Find the maximum length\n        max_len = max(len(seq) for seq in all_sequences)\n\n        # Create cycled iterators for each sequence\n        cycled_iterators = [itertools.cycle(seq) for seq in all_sequences]\n\n        # Zip them together for max_len items\n        result = []\n        for _ in range(max_len):\n            result.append(tuple(next(it) for it in cycled_iterators))\n\n        return Slist(result)\n\n    def slice_with_bool(self, bools: Sequence[bool]) -&gt; Slist[A]:\n        \"\"\"Slice the list using a sequence of boolean values.\n\n        Parameters\n        ----------\n        bools : Sequence[bool]\n            Boolean sequence indicating which elements to keep\n\n        Returns\n        -------\n        Slist[A]\n            List containing elements where corresponding boolean is True\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3, 4, 5]).slice_with_bool([True, False, True, False, True])\n        Slist([1, 3, 5])\n        \"\"\"\n        return Slist(item for item, keep in zip(self, bools) if keep)\n\n    def __mul__(self, other: typing.SupportsIndex) -&gt; Slist[A]:\n        return Slist(super().__mul__(other))\n\n    @classmethod\n    def __get_pydantic_core_schema__(cls, source_type: Any, handler):  # type: ignore\n        # only called by pydantic v2\n        from pydantic_core import core_schema  # type: ignore\n\n        return core_schema.no_info_after_validator_function(cls, handler(list))\n\n    def find_one_or_raise(\n        self,\n        predicate: Callable[[A], bool],\n        exception: Exception = RuntimeError(\"Failed to find predicate\"),\n    ) -&gt; A:\n        \"\"\"Find first element that satisfies a predicate or raise exception.\n\n        Parameters\n        ----------\n        predicate : Callable[[A], bool]\n            Function that returns True for the desired element\n        exception : Exception, optional\n            Exception to raise if no match found, by default RuntimeError(\"Failed to find predicate\")\n\n        Returns\n        -------\n        A\n            First matching element\n\n        Raises\n        ------\n        Exception\n            If no matching element is found\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2, 3, 4]).find_one_or_raise(lambda x: x &gt; 3)\n        4\n        &gt;&gt;&gt; try:\n        ...     Slist([1, 2, 3]).find_one_or_raise(lambda x: x &gt; 5)\n        ... except RuntimeError as e:\n        ...     print(str(e))\n        Failed to find predicate\n        \"\"\"\n        result = self.find_one(predicate)\n        if result is not None:\n            return result\n        else:\n            raise exception\n\n    def permutations_pairs(self) -&gt; Slist[Tuple[A, A]]:\n        \"\"\"Generate all possible pairs of elements, including reversed pairs.\n\n        This method uses itertools.permutations with length=2,\n        but filters out pairs where both elements are the same.\n\n        Returns\n        -------\n        Slist[Tuple[A, A]]\n            A new Slist containing all pairs of elements\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2]).permutations_pairs()\n        Slist([(1, 2), (2, 1)])\n        &gt;&gt;&gt; Slist([1, 2, 3]).permutations_pairs()\n        Slist([(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)])\n        &gt;&gt;&gt; Slist([]).permutations_pairs()\n        Slist([])\n        &gt;&gt;&gt; Slist([1]).permutations_pairs()\n        Slist([])\n        \"\"\"\n        result = Slist(perm for perm in itertools.permutations(self, 2))\n        return result\n\n    def combinations_pairs(self) -&gt; Slist[Tuple[A, A]]:\n        \"\"\"Generate pairs of elements without including reversed pairs.\n\n        This method uses itertools.combinations with length=2.\n\n        Returns\n        -------\n        Slist[Tuple[A, A]]\n            A new Slist containing unique pairs of elements\n\n        Examples\n        --------\n        &gt;&gt;&gt; Slist([1, 2]).combinations_pairs()\n        Slist([(1, 2)])\n        &gt;&gt;&gt; Slist([1, 2, 3]).combinations_pairs()\n        Slist([(1, 2), (1, 3), (2, 3)])\n        &gt;&gt;&gt; Slist([]).combinations_pairs()\n        Slist([])\n        &gt;&gt;&gt; Slist([1]).combinations_pairs()\n        Slist([])\n        \"\"\"\n        result = Slist(itertools.combinations(self, 2))\n        return result\n</code></pre>"},{"location":"api/slist/#slist.Slist-attributes","title":"Attributes","text":""},{"location":"api/slist/#slist.Slist.is_empty","title":"is_empty  <code>property</code>","text":"<pre><code>is_empty: bool\n</code></pre> <p>Check if the list is empty.</p>"},{"location":"api/slist/#slist.Slist.is_empty--returns","title":"Returns","text":"<p>bool     True if the list has no elements</p>"},{"location":"api/slist/#slist.Slist.is_empty--examples","title":"Examples","text":"<p>Slist([]).is_empty True Slist([1]).is_empty False</p>"},{"location":"api/slist/#slist.Slist.not_empty","title":"not_empty  <code>property</code>","text":"<pre><code>not_empty: bool\n</code></pre> <p>Check if the list has any elements.</p>"},{"location":"api/slist/#slist.Slist.not_empty--returns","title":"Returns","text":"<p>bool     True if the list has at least one element</p>"},{"location":"api/slist/#slist.Slist.not_empty--examples","title":"Examples","text":"<p>Slist([1]).not_empty True Slist([]).not_empty False</p>"},{"location":"api/slist/#slist.Slist.length","title":"length  <code>property</code>","text":"<pre><code>length: int\n</code></pre> <p>Get the number of elements in the list.</p>"},{"location":"api/slist/#slist.Slist.length--returns","title":"Returns","text":"<p>int     Number of elements</p>"},{"location":"api/slist/#slist.Slist.length--examples","title":"Examples","text":"<p>Slist([1, 2, 3]).length 3</p>"},{"location":"api/slist/#slist.Slist.last_option","title":"last_option  <code>property</code>","text":"<pre><code>last_option: Optional[A]\n</code></pre> <p>Get the last element if it exists.</p>"},{"location":"api/slist/#slist.Slist.last_option--returns","title":"Returns","text":"<p>Optional[A]     Last element, or None if list is empty</p>"},{"location":"api/slist/#slist.Slist.last_option--examples","title":"Examples","text":"<p>Slist([1, 2, 3]).last_option 3 Slist([]).last_option None</p>"},{"location":"api/slist/#slist.Slist.first_option","title":"first_option  <code>property</code>","text":"<pre><code>first_option: Optional[A]\n</code></pre> <p>Get the first element if it exists.</p>"},{"location":"api/slist/#slist.Slist.first_option--returns","title":"Returns","text":"<p>Optional[A]     First element, or None if list is empty</p>"},{"location":"api/slist/#slist.Slist.first_option--examples","title":"Examples","text":"<p>Slist([1, 2, 3]).first_option 1 Slist([]).first_option None</p>"},{"location":"api/slist/#slist.Slist.mode_option","title":"mode_option  <code>property</code>","text":"<pre><code>mode_option: Optional[A]\n</code></pre> <p>Get the most common element if it exists.</p>"},{"location":"api/slist/#slist.Slist.mode_option--returns","title":"Returns","text":"<p>Optional[A]     Most frequent element, or None if list is empty or has no unique mode</p>"},{"location":"api/slist/#slist.Slist.mode_option--examples","title":"Examples","text":"<p>Slist([1, 2, 2, 3]).mode_option 2 Slist([1, 1, 2, 2]).mode_option  # No unique mode None Slist([]).mode_option None</p>"},{"location":"api/slist/#slist.Slist-functions","title":"Functions","text":""},{"location":"api/slist/#slist.Slist.one","title":"one  <code>staticmethod</code>","text":"<pre><code>one(element: A) -&gt; Slist[A]\n</code></pre> <p>Create a new Slist with a single element.</p>"},{"location":"api/slist/#slist.Slist.one--parameters","title":"Parameters","text":"<p>element : A     The element to create the list with</p>"},{"location":"api/slist/#slist.Slist.one--returns","title":"Returns","text":"<p>Slist[A]     A new Slist containing only the given element</p>"},{"location":"api/slist/#slist.Slist.one--examples","title":"Examples","text":"<p>Slist.one(5) Slist([5])</p> Source code in <code>slist/__init__.py</code> <pre><code>@staticmethod\ndef one(element: A) -&gt; Slist[A]:\n    \"\"\"Create a new Slist with a single element.\n\n    Parameters\n    ----------\n    element : A\n        The element to create the list with\n\n    Returns\n    -------\n    Slist[A]\n        A new Slist containing only the given element\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist.one(5)\n    Slist([5])\n    \"\"\"\n    return Slist([element])\n</code></pre>"},{"location":"api/slist/#slist.Slist.one_option","title":"one_option  <code>staticmethod</code>","text":"<pre><code>one_option(element: Optional[A]) -&gt; Slist[A]\n</code></pre> <p>Create a Slist with one element if it exists, otherwise empty list.</p> <p>Equal to <code>Slist.one(element).flatten_option()</code></p>"},{"location":"api/slist/#slist.Slist.one_option--parameters","title":"Parameters","text":"<p>element : Optional[A]     The element to create the list with, if it exists</p>"},{"location":"api/slist/#slist.Slist.one_option--returns","title":"Returns","text":"<p>Slist[A]     A new Slist containing the element if it exists, otherwise empty</p>"},{"location":"api/slist/#slist.Slist.one_option--examples","title":"Examples","text":"<p>Slist.one_option(5) Slist([5]) Slist.one_option(None) Slist([])</p> Source code in <code>slist/__init__.py</code> <pre><code>@staticmethod\ndef one_option(element: Optional[A]) -&gt; Slist[A]:\n    \"\"\"Create a Slist with one element if it exists, otherwise empty list.\n\n    Equal to ``Slist.one(element).flatten_option()``\n\n    Parameters\n    ----------\n    element : Optional[A]\n        The element to create the list with, if it exists\n\n    Returns\n    -------\n    Slist[A]\n        A new Slist containing the element if it exists, otherwise empty\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist.one_option(5)\n    Slist([5])\n    &gt;&gt;&gt; Slist.one_option(None)\n    Slist([])\n    \"\"\"\n    return Slist([element]) if element is not None else Slist()\n</code></pre>"},{"location":"api/slist/#slist.Slist.any","title":"any","text":"<pre><code>any(predicate: Callable[[A], bool]) -&gt; bool\n</code></pre> <p>Check if any element satisfies the predicate.</p>"},{"location":"api/slist/#slist.Slist.any--parameters","title":"Parameters","text":"<p>predicate : Callable[[A], bool]     Function that takes an element and returns True/False</p>"},{"location":"api/slist/#slist.Slist.any--returns","title":"Returns","text":"<p>bool     True if any element satisfies the predicate, False otherwise</p>"},{"location":"api/slist/#slist.Slist.any--examples","title":"Examples","text":"<p>Slist([1, 2, 3, 4]).any(lambda x: x &gt; 3) True Slist([1, 2, 3]).any(lambda x: x &gt; 3) False</p> Source code in <code>slist/__init__.py</code> <pre><code>def any(self, predicate: Callable[[A], bool]) -&gt; bool:\n    \"\"\"Check if any element satisfies the predicate.\n\n    Parameters\n    ----------\n    predicate : Callable[[A], bool]\n        Function that takes an element and returns True/False\n\n    Returns\n    -------\n    bool\n        True if any element satisfies the predicate, False otherwise\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3, 4]).any(lambda x: x &gt; 3)\n    True\n    &gt;&gt;&gt; Slist([1, 2, 3]).any(lambda x: x &gt; 3)\n    False\n    \"\"\"\n    for x in self:\n        if predicate(x):\n            return True\n    return False\n</code></pre>"},{"location":"api/slist/#slist.Slist.all","title":"all","text":"<pre><code>all(predicate: Callable[[A], bool]) -&gt; bool\n</code></pre> <p>Check if all elements satisfy the predicate.</p>"},{"location":"api/slist/#slist.Slist.all--parameters","title":"Parameters","text":"<p>predicate : Callable[[A], bool]     Function that takes an element and returns True/False</p>"},{"location":"api/slist/#slist.Slist.all--returns","title":"Returns","text":"<p>bool     True if all elements satisfy the predicate, False otherwise</p>"},{"location":"api/slist/#slist.Slist.all--examples","title":"Examples","text":"<p>Slist([2, 4, 6]).all(lambda x: x % 2 == 0) True Slist([2, 3, 4]).all(lambda x: x % 2 == 0) False</p> Source code in <code>slist/__init__.py</code> <pre><code>def all(self, predicate: Callable[[A], bool]) -&gt; bool:\n    \"\"\"Check if all elements satisfy the predicate.\n\n    Parameters\n    ----------\n    predicate : Callable[[A], bool]\n        Function that takes an element and returns True/False\n\n    Returns\n    -------\n    bool\n        True if all elements satisfy the predicate, False otherwise\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([2, 4, 6]).all(lambda x: x % 2 == 0)\n    True\n    &gt;&gt;&gt; Slist([2, 3, 4]).all(lambda x: x % 2 == 0)\n    False\n    \"\"\"\n    for x in self:\n        if not predicate(x):\n            return False\n    return True\n</code></pre>"},{"location":"api/slist/#slist.Slist.filter","title":"filter","text":"<pre><code>filter(predicate: Callable[[A], bool]) -&gt; Slist[A]\n</code></pre> <p>Create a new Slist with only elements that satisfy the predicate.</p>"},{"location":"api/slist/#slist.Slist.filter--parameters","title":"Parameters","text":"<p>predicate : Callable[[A], bool]     Function that takes an element and returns True/False</p>"},{"location":"api/slist/#slist.Slist.filter--returns","title":"Returns","text":"<p>Slist[A]     A new Slist containing only elements that satisfy the predicate</p>"},{"location":"api/slist/#slist.Slist.filter--examples","title":"Examples","text":"<p>Slist([1, 2, 3, 4]).filter(lambda x: x % 2 == 0) Slist([2, 4])</p> Source code in <code>slist/__init__.py</code> <pre><code>def filter(self, predicate: Callable[[A], bool]) -&gt; Slist[A]:\n    \"\"\"Create a new Slist with only elements that satisfy the predicate.\n\n    Parameters\n    ----------\n    predicate : Callable[[A], bool]\n        Function that takes an element and returns True/False\n\n    Returns\n    -------\n    Slist[A]\n        A new Slist containing only elements that satisfy the predicate\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3, 4]).filter(lambda x: x % 2 == 0)\n    Slist([2, 4])\n    \"\"\"\n    return Slist(filter(predicate, self))\n</code></pre>"},{"location":"api/slist/#slist.Slist.map","title":"map","text":"<pre><code>map(func: Callable[[A], B]) -&gt; Slist[B]\n</code></pre> <p>Transform each element using the given function.</p>"},{"location":"api/slist/#slist.Slist.map--parameters","title":"Parameters","text":"<p>func : Callable[[A], B]     Function to apply to each element</p>"},{"location":"api/slist/#slist.Slist.map--returns","title":"Returns","text":"<p>Slist[B]     A new Slist with transformed elements</p>"},{"location":"api/slist/#slist.Slist.map--examples","title":"Examples","text":"<p>Slist([1, 2, 3]).map(lambda x: x * 2) Slist([2, 4, 6])</p> Source code in <code>slist/__init__.py</code> <pre><code>def map(self, func: Callable[[A], B]) -&gt; Slist[B]:\n    \"\"\"Transform each element using the given function.\n\n    Parameters\n    ----------\n    func : Callable[[A], B]\n        Function to apply to each element\n\n    Returns\n    -------\n    Slist[B]\n        A new Slist with transformed elements\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3]).map(lambda x: x * 2)\n    Slist([2, 4, 6])\n    \"\"\"\n    return Slist(func(item) for item in self)\n</code></pre>"},{"location":"api/slist/#slist.Slist.product","title":"product","text":"<pre><code>product(other: Sequence[B]) -&gt; Slist[Tuple[A, B]]\n</code></pre><pre><code>product(other: Sequence[B], other1: Sequence[C]) -&gt; Slist[Tuple[A, B, C]]\n</code></pre><pre><code>product(other: Sequence[B], other1: Sequence[C], other2: Sequence[D]) -&gt; Slist[Tuple[A, B, C, D]]\n</code></pre><pre><code>product(other: Sequence[B], other1: Sequence[C], other2: Sequence[D], other3: Sequence[E]) -&gt; Slist[Tuple[A, B, C, D, E]]\n</code></pre><pre><code>product(other: Sequence[B], other1: Sequence[C], other2: Sequence[D], other3: Sequence[E], other4: Sequence[F]) -&gt; Slist[Tuple[A, B, C, D, E, F]]\n</code></pre> <pre><code>product(*others: Sequence[Any]) -&gt; Slist[Tuple[Any, ...]]\n</code></pre> <p>Compute the cartesian product with other sequences.</p>"},{"location":"api/slist/#slist.Slist.product--parameters","title":"Parameters","text":"<p>*others : Sequence[Any]     The sequences to compute the product with</p>"},{"location":"api/slist/#slist.Slist.product--returns","title":"Returns","text":"<p>Slist[Tuple[Any, ...]]     A new Slist containing tuples of all combinations</p>"},{"location":"api/slist/#slist.Slist.product--examples","title":"Examples","text":"<p>Slist([1, 2]).product(['a', 'b']) Slist([(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')])</p> Source code in <code>slist/__init__.py</code> <pre><code>def product(self: Sequence[A], *others: Sequence[Any]) -&gt; Slist[Tuple[Any, ...]]:\n    \"\"\"Compute the cartesian product with other sequences.\n\n    Parameters\n    ----------\n    *others : Sequence[Any]\n        The sequences to compute the product with\n\n    Returns\n    -------\n    Slist[Tuple[Any, ...]]\n        A new Slist containing tuples of all combinations\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2]).product(['a', 'b'])\n    Slist([(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')])\n    \"\"\"\n    return Slist(itertools.product(self, *others))\n</code></pre>"},{"location":"api/slist/#slist.Slist.map_2","title":"map_2","text":"<pre><code>map_2(func: Callable[[B, C], D]) -&gt; Slist[D]\n</code></pre> <p>Map a function over a sequence of 2-tuples.</p>"},{"location":"api/slist/#slist.Slist.map_2--parameters","title":"Parameters","text":"<p>func : Callable[[B, C], D]     Function that takes two arguments and returns a value</p>"},{"location":"api/slist/#slist.Slist.map_2--returns","title":"Returns","text":"<p>Slist[D]     A new Slist with the results of applying func to each tuple</p>"},{"location":"api/slist/#slist.Slist.map_2--examples","title":"Examples","text":"<p>pairs = Slist([(1, 2), (3, 4)]) pairs.map_2(lambda x, y: x + y) Slist([3, 7])</p> Source code in <code>slist/__init__.py</code> <pre><code>def map_2(self: Sequence[Tuple[B, C]], func: Callable[[B, C], D]) -&gt; Slist[D]:\n    \"\"\"Map a function over a sequence of 2-tuples.\n\n    Parameters\n    ----------\n    func : Callable[[B, C], D]\n        Function that takes two arguments and returns a value\n\n    Returns\n    -------\n    Slist[D]\n        A new Slist with the results of applying func to each tuple\n\n    Examples\n    --------\n    &gt;&gt;&gt; pairs = Slist([(1, 2), (3, 4)])\n    &gt;&gt;&gt; pairs.map_2(lambda x, y: x + y)\n    Slist([3, 7])\n    \"\"\"\n    return Slist(func(b, c) for b, c in self)\n</code></pre>"},{"location":"api/slist/#slist.Slist.map_enumerate","title":"map_enumerate","text":"<pre><code>map_enumerate(func: Callable[[int, A], B]) -&gt; Slist[B]\n</code></pre> <p>Map a function over the list with indices.</p>"},{"location":"api/slist/#slist.Slist.map_enumerate--parameters","title":"Parameters","text":"<p>func : Callable[[int, A], B]     Function that takes an index and value and returns a new value</p>"},{"location":"api/slist/#slist.Slist.map_enumerate--returns","title":"Returns","text":"<p>Slist[B]     A new Slist with the results of applying func to each (index, value) pair</p>"},{"location":"api/slist/#slist.Slist.map_enumerate--examples","title":"Examples","text":"<p>Slist(['a', 'b', 'c']).map_enumerate(lambda i, x: f\"{i}:{x}\") Slist(['0:a', '1:b', '2:c'])</p> Source code in <code>slist/__init__.py</code> <pre><code>def map_enumerate(self, func: Callable[[int, A], B]) -&gt; Slist[B]:\n    \"\"\"Map a function over the list with indices.\n\n    Parameters\n    ----------\n    func : Callable[[int, A], B]\n        Function that takes an index and value and returns a new value\n\n    Returns\n    -------\n    Slist[B]\n        A new Slist with the results of applying func to each (index, value) pair\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist(['a', 'b', 'c']).map_enumerate(lambda i, x: f\"{i}:{x}\")\n    Slist(['0:a', '1:b', '2:c'])\n    \"\"\"\n    return Slist(func(idx, item) for idx, item in enumerate(self))\n</code></pre>"},{"location":"api/slist/#slist.Slist.flatten_option","title":"flatten_option","text":"<pre><code>flatten_option() -&gt; Slist[B]\n</code></pre> <p>Remove None values from a sequence of optional values.</p>"},{"location":"api/slist/#slist.Slist.flatten_option--parameters","title":"Parameters","text":"<p>self : Sequence[Optional[B]]     A sequence containing optional values</p>"},{"location":"api/slist/#slist.Slist.flatten_option--returns","title":"Returns","text":"<p>Slist[B]     A new Slist with all non-None values</p>"},{"location":"api/slist/#slist.Slist.flatten_option--examples","title":"Examples","text":"<p>Slist([1, None, 3, None, 5]).flatten_option() Slist([1, 3, 5])</p> Source code in <code>slist/__init__.py</code> <pre><code>def flatten_option(self: Sequence[Optional[B]]) -&gt; Slist[B]:\n    \"\"\"Remove None values from a sequence of optional values.\n\n    Parameters\n    ----------\n    self : Sequence[Optional[B]]\n        A sequence containing optional values\n\n    Returns\n    -------\n    Slist[B]\n        A new Slist with all non-None values\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, None, 3, None, 5]).flatten_option()\n    Slist([1, 3, 5])\n    \"\"\"\n    return Slist([item for item in self if item is not None])\n</code></pre>"},{"location":"api/slist/#slist.Slist.flat_map_option","title":"flat_map_option","text":"<pre><code>flat_map_option(func: Callable[[A], Optional[B]]) -&gt; Slist[B]\n</code></pre> <p>Apply a function that returns optional values and filter out Nones.</p>"},{"location":"api/slist/#slist.Slist.flat_map_option--parameters","title":"Parameters","text":"<p>func : Callable[[A], Optional[B]]     Function that takes a value and returns an optional value</p>"},{"location":"api/slist/#slist.Slist.flat_map_option--returns","title":"Returns","text":"<p>Slist[B]     A new Slist with all non-None results of applying func</p>"},{"location":"api/slist/#slist.Slist.flat_map_option--examples","title":"Examples","text":"<p>def safe_sqrt(x: float) -&gt; Optional[float]: ...     return x ** 0.5 if x &gt;= 0 else None Slist([4, -1, 9, -4, 16]).flat_map_option(safe_sqrt) Slist([2.0, 3.0, 4.0])</p> Source code in <code>slist/__init__.py</code> <pre><code>def flat_map_option(self, func: Callable[[A], Optional[B]]) -&gt; Slist[B]:\n    \"\"\"Apply a function that returns optional values and filter out Nones.\n\n    Parameters\n    ----------\n    func : Callable[[A], Optional[B]]\n        Function that takes a value and returns an optional value\n\n    Returns\n    -------\n    Slist[B]\n        A new Slist with all non-None results of applying func\n\n    Examples\n    --------\n    &gt;&gt;&gt; def safe_sqrt(x: float) -&gt; Optional[float]:\n    ...     return x ** 0.5 if x &gt;= 0 else None\n    &gt;&gt;&gt; Slist([4, -1, 9, -4, 16]).flat_map_option(safe_sqrt)\n    Slist([2.0, 3.0, 4.0])\n    \"\"\"\n    return self.map(func).flatten_option()\n</code></pre>"},{"location":"api/slist/#slist.Slist.upsample_if","title":"upsample_if","text":"<pre><code>upsample_if(predicate: Callable[[A], bool], upsample_by: int) -&gt; Slist[A]\n</code></pre> <p>Repeat elements that satisfy a predicate.</p>"},{"location":"api/slist/#slist.Slist.upsample_if--parameters","title":"Parameters","text":"<p>predicate : Callable[[A], bool]     Function that determines which elements to upsample upsample_by : int     Number of times to repeat each matching element</p>"},{"location":"api/slist/#slist.Slist.upsample_if--returns","title":"Returns","text":"<p>Slist[A]     A new Slist with matching elements repeated</p>"},{"location":"api/slist/#slist.Slist.upsample_if--examples","title":"Examples","text":"<p>numbers = Slist([1, 2, 3, 4]) numbers.upsample_if(lambda x: x % 2 == 0, upsample_by=2) Slist([1, 2, 2, 3, 4, 4])</p> Source code in <code>slist/__init__.py</code> <pre><code>def upsample_if(self, predicate: Callable[[A], bool], upsample_by: int) -&gt; Slist[A]:\n    \"\"\"Repeat elements that satisfy a predicate.\n\n    Parameters\n    ----------\n    predicate : Callable[[A], bool]\n        Function that determines which elements to upsample\n    upsample_by : int\n        Number of times to repeat each matching element\n\n    Returns\n    -------\n    Slist[A]\n        A new Slist with matching elements repeated\n\n    Examples\n    --------\n    &gt;&gt;&gt; numbers = Slist([1, 2, 3, 4])\n    &gt;&gt;&gt; numbers.upsample_if(lambda x: x % 2 == 0, upsample_by=2)\n    Slist([1, 2, 2, 3, 4, 4])\n    \"\"\"\n    assert upsample_by &gt; 0, \"upsample_by must be positive\"\n    new_list = Slist[A]()\n    for item in self:\n        if predicate(item):\n            for _ in range(upsample_by):\n                new_list.append(item)\n        else:\n            new_list.append(item)\n    return new_list\n</code></pre>"},{"location":"api/slist/#slist.Slist.flatten_list","title":"flatten_list","text":"<pre><code>flatten_list() -&gt; Slist[B]\n</code></pre> <p>Flatten a sequence of sequences into a single list.</p>"},{"location":"api/slist/#slist.Slist.flatten_list--parameters","title":"Parameters","text":"<p>self : Sequence[Sequence[B]]     A sequence of sequences to flatten</p>"},{"location":"api/slist/#slist.Slist.flatten_list--returns","title":"Returns","text":"<p>Slist[B]     A new Slist with all elements from all sequences</p>"},{"location":"api/slist/#slist.Slist.flatten_list--examples","title":"Examples","text":"<p>nested = Slist([[1, 2], [3, 4], [5, 6]]) nested.flatten_list() Slist([1, 2, 3, 4, 5, 6])</p> Source code in <code>slist/__init__.py</code> <pre><code>def flatten_list(self: Sequence[Sequence[B]]) -&gt; Slist[B]:\n    \"\"\"Flatten a sequence of sequences into a single list.\n\n    Parameters\n    ----------\n    self : Sequence[Sequence[B]]\n        A sequence of sequences to flatten\n\n    Returns\n    -------\n    Slist[B]\n        A new Slist with all elements from all sequences\n\n    Examples\n    --------\n    &gt;&gt;&gt; nested = Slist([[1, 2], [3, 4], [5, 6]])\n    &gt;&gt;&gt; nested.flatten_list()\n    Slist([1, 2, 3, 4, 5, 6])\n    \"\"\"\n    flat_list: Slist[B] = Slist()\n    for sublist in self:\n        for item in sublist:\n            flat_list.append(item)\n    return flat_list\n</code></pre>"},{"location":"api/slist/#slist.Slist.enumerated","title":"enumerated","text":"<pre><code>enumerated() -&gt; Slist[Tuple[int, A]]\n</code></pre> <p>Create a list of tuples containing indices and values.</p>"},{"location":"api/slist/#slist.Slist.enumerated--returns","title":"Returns","text":"<p>Slist[Tuple[int, A]]     A new Slist of (index, value) tuples</p>"},{"location":"api/slist/#slist.Slist.enumerated--examples","title":"Examples","text":"<p>Slist(['a', 'b', 'c']).enumerated() Slist([(0, 'a'), (1, 'b'), (2, 'c')])</p> Source code in <code>slist/__init__.py</code> <pre><code>def enumerated(self) -&gt; Slist[Tuple[int, A]]:\n    \"\"\"Create a list of tuples containing indices and values.\n\n    Returns\n    -------\n    Slist[Tuple[int, A]]\n        A new Slist of (index, value) tuples\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist(['a', 'b', 'c']).enumerated()\n    Slist([(0, 'a'), (1, 'b'), (2, 'c')])\n    \"\"\"\n    return Slist(enumerate(self))\n</code></pre>"},{"location":"api/slist/#slist.Slist.shuffle","title":"shuffle","text":"<pre><code>shuffle(seed: Optional[str] = None) -&gt; Slist[A]\n</code></pre> <p>Create a new randomly shuffled list.</p>"},{"location":"api/slist/#slist.Slist.shuffle--parameters","title":"Parameters","text":"<p>seed : Optional[str], optional     Random seed for reproducibility, by default None</p>"},{"location":"api/slist/#slist.Slist.shuffle--returns","title":"Returns","text":"<p>Slist[A]     A new Slist with elements in random order</p>"},{"location":"api/slist/#slist.Slist.shuffle--examples","title":"Examples","text":"<p>Slist([1, 2, 3, 4]).shuffle(seed=\"42\")  # Reproducible shuffle Slist([2, 4, 1, 3])</p> Source code in <code>slist/__init__.py</code> <pre><code>def shuffle(self, seed: Optional[str] = None) -&gt; Slist[A]:\n    \"\"\"Create a new randomly shuffled list.\n\n    Parameters\n    ----------\n    seed : Optional[str], optional\n        Random seed for reproducibility, by default None\n\n    Returns\n    -------\n    Slist[A]\n        A new Slist with elements in random order\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3, 4]).shuffle(seed=\"42\")  # Reproducible shuffle\n    Slist([2, 4, 1, 3])\n    \"\"\"\n    new = self.copy()\n    random.Random(seed).shuffle(new)\n    return Slist(new)\n</code></pre>"},{"location":"api/slist/#slist.Slist.choice","title":"choice","text":"<pre><code>choice(seed: Optional[str] = None, weights: Optional[List[int]] = None) -&gt; A\n</code></pre> <p>Randomly select an element from the list.</p>"},{"location":"api/slist/#slist.Slist.choice--parameters","title":"Parameters","text":"<p>seed : Optional[str], optional     Random seed for reproducibility, by default None weights : Optional[List[int]], optional     List of weights for weighted random selection, by default None</p>"},{"location":"api/slist/#slist.Slist.choice--returns","title":"Returns","text":"<p>A     A randomly selected element</p>"},{"location":"api/slist/#slist.Slist.choice--examples","title":"Examples","text":"<p>Slist([1, 2, 3, 4]).choice(seed=\"42\")  # Reproducible choice 2 Slist([1, 2, 3]).choice(weights=[1, 2, 1])  # Weighted choice 2  # More likely to select 2 due to higher weight</p> Source code in <code>slist/__init__.py</code> <pre><code>def choice(\n    self,\n    seed: Optional[str] = None,\n    weights: Optional[List[int]] = None,\n) -&gt; A:\n    \"\"\"Randomly select an element from the list.\n\n    Parameters\n    ----------\n    seed : Optional[str], optional\n        Random seed for reproducibility, by default None\n    weights : Optional[List[int]], optional\n        List of weights for weighted random selection, by default None\n\n    Returns\n    -------\n    A\n        A randomly selected element\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3, 4]).choice(seed=\"42\")  # Reproducible choice\n    2\n    &gt;&gt;&gt; Slist([1, 2, 3]).choice(weights=[1, 2, 1])  # Weighted choice\n    2  # More likely to select 2 due to higher weight\n    \"\"\"\n    if weights:\n        return random.Random(seed).choices(self, weights=weights, k=1)[0]\n    else:\n        return random.Random(seed).choice(self)\n</code></pre>"},{"location":"api/slist/#slist.Slist.sample","title":"sample","text":"<pre><code>sample(n: int, seed: Optional[str] = None) -&gt; Slist[A]\n</code></pre> <p>Randomly sample n elements from the list without replacement.</p>"},{"location":"api/slist/#slist.Slist.sample--parameters","title":"Parameters","text":"<p>n : int     Number of elements to sample seed : Optional[str], optional     Random seed for reproducibility, by default None</p>"},{"location":"api/slist/#slist.Slist.sample--returns","title":"Returns","text":"<p>Slist[A]     A new Slist with n randomly selected elements</p>"},{"location":"api/slist/#slist.Slist.sample--examples","title":"Examples","text":"<p>Slist([1, 2, 3, 4, 5]).sample(3, seed=\"42\") Slist([2, 4, 1])</p> Source code in <code>slist/__init__.py</code> <pre><code>def sample(self, n: int, seed: Optional[str] = None) -&gt; Slist[A]:\n    \"\"\"Randomly sample n elements from the list without replacement.\n\n    Parameters\n    ----------\n    n : int\n        Number of elements to sample\n    seed : Optional[str], optional\n        Random seed for reproducibility, by default None\n\n    Returns\n    -------\n    Slist[A]\n        A new Slist with n randomly selected elements\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3, 4, 5]).sample(3, seed=\"42\")\n    Slist([2, 4, 1])\n    \"\"\"\n    return Slist(random.Random(seed).sample(self, n))\n</code></pre>"},{"location":"api/slist/#slist.Slist.for_each","title":"for_each","text":"<pre><code>for_each(func: Callable[[A], None]) -&gt; Slist[A]\n</code></pre> <p>Apply a side-effect function to each element and return the original list.</p>"},{"location":"api/slist/#slist.Slist.for_each--parameters","title":"Parameters","text":"<p>func : Callable[[A], None]     Function to apply to each element for its side effects</p>"},{"location":"api/slist/#slist.Slist.for_each--returns","title":"Returns","text":"<p>Slist[A]     The original list, unchanged</p>"},{"location":"api/slist/#slist.Slist.for_each--examples","title":"Examples","text":"<p>nums = Slist([1, 2, 3]) nums.for_each(print)  # Prints each number 1 2 3 nums  # Original list is unchanged Slist([1, 2, 3])</p> Source code in <code>slist/__init__.py</code> <pre><code>def for_each(self, func: Callable[[A], None]) -&gt; Slist[A]:\n    \"\"\"Apply a side-effect function to each element and return the original list.\n\n    Parameters\n    ----------\n    func : Callable[[A], None]\n        Function to apply to each element for its side effects\n\n    Returns\n    -------\n    Slist[A]\n        The original list, unchanged\n\n    Examples\n    --------\n    &gt;&gt;&gt; nums = Slist([1, 2, 3])\n    &gt;&gt;&gt; nums.for_each(print)  # Prints each number\n    1\n    2\n    3\n    &gt;&gt;&gt; nums  # Original list is unchanged\n    Slist([1, 2, 3])\n    \"\"\"\n    for item in self:\n        func(item)\n    return self\n</code></pre>"},{"location":"api/slist/#slist.Slist.group_by","title":"group_by","text":"<pre><code>group_by(key: Callable[[A], CanHash]) -&gt; Slist[Group[CanHash, Slist[A]]]\n</code></pre> <p>Group elements by a key function.</p>"},{"location":"api/slist/#slist.Slist.group_by--parameters","title":"Parameters","text":"<p>key : Callable[[A], CanHash]     Function to compute the group key for each element</p>"},{"location":"api/slist/#slist.Slist.group_by--returns","title":"Returns","text":"<p>Slist[Group[CanHash, Slist[A]]]     A new Slist of Groups, where each Group contains:         - key: The grouping key         - values: Slist of elements in that group</p>"},{"location":"api/slist/#slist.Slist.group_by--examples","title":"Examples","text":"<p>numbers = Slist([1, 2, 3, 4]) groups = numbers.group_by(lambda x: x % 2)  # Group by even/odd groups.map(lambda g: (g.key, list(g.values))) Slist([(1, [1, 3]), (0, [2, 4])])</p> Source code in <code>slist/__init__.py</code> <pre><code>def group_by(self, key: Callable[[A], CanHash]) -&gt; Slist[Group[CanHash, Slist[A]]]:\n    \"\"\"Group elements by a key function.\n\n    Parameters\n    ----------\n    key : Callable[[A], CanHash]\n        Function to compute the group key for each element\n\n    Returns\n    -------\n    Slist[Group[CanHash, Slist[A]]]\n        A new Slist of Groups, where each Group contains:\n            - key: The grouping key\n            - values: Slist of elements in that group\n\n    Examples\n    --------\n    &gt;&gt;&gt; numbers = Slist([1, 2, 3, 4])\n    &gt;&gt;&gt; groups = numbers.group_by(lambda x: x % 2)  # Group by even/odd\n    &gt;&gt;&gt; groups.map(lambda g: (g.key, list(g.values)))\n    Slist([(1, [1, 3]), (0, [2, 4])])\n    \"\"\"\n    d: typing.OrderedDict[CanHash, Slist[A]] = OrderedDict()\n    for elem in self:\n        k = key(elem)\n        if k in d:\n            d[k].append(elem)\n        else:\n            d[k] = Slist([elem])\n    return Slist(Group(key=key, values=value) for key, value in d.items())\n</code></pre>"},{"location":"api/slist/#slist.Slist.ungroup","title":"ungroup","text":"<pre><code>ungroup() -&gt; Slist[C]\n</code></pre><pre><code>ungroup() -&gt; Slist[C]\n</code></pre> <pre><code>ungroup() -&gt; Slist[C]\n</code></pre> <p>Convert a list of groups back into a flat list of values.</p>"},{"location":"api/slist/#slist.Slist.ungroup--parameters","title":"Parameters","text":"<p>self : Slist[Group[Any, Slist[C]]] | Slist[Group[Any, Sequence[C]]]     A list of groups to ungroup</p>"},{"location":"api/slist/#slist.Slist.ungroup--returns","title":"Returns","text":"<p>Slist[C]     A flat list containing all values from all groups</p>"},{"location":"api/slist/#slist.Slist.ungroup--examples","title":"Examples","text":"<p>groups = Slist([Group(0, [1, 2]), Group(1, [3, 4])]) groups.ungroup() Slist([1, 2, 3, 4])</p> Source code in <code>slist/__init__.py</code> <pre><code>def ungroup(self: Slist[Group[Any, Slist[C]]] | Slist[Group[Any, Sequence[C]]]) -&gt; Slist[C]:\n    \"\"\"Convert a list of groups back into a flat list of values.\n\n    Parameters\n    ----------\n    self : Slist[Group[Any, Slist[C]]] | Slist[Group[Any, Sequence[C]]]\n        A list of groups to ungroup\n\n    Returns\n    -------\n    Slist[C]\n        A flat list containing all values from all groups\n\n    Examples\n    --------\n    &gt;&gt;&gt; groups = Slist([Group(0, [1, 2]), Group(1, [3, 4])])\n    &gt;&gt;&gt; groups.ungroup()\n    Slist([1, 2, 3, 4])\n    \"\"\"\n    casted: Slist[Group[Any, Slist[C]]] = self  # type: ignore\n    return casted.map_2(lambda _, values: values).flatten_list()\n</code></pre>"},{"location":"api/slist/#slist.Slist.map_on_group_values","title":"map_on_group_values","text":"<pre><code>map_on_group_values(func: Callable[[Slist[C]], D]) -&gt; Slist[Group[B, D]]\n</code></pre> <p>Apply a function to the values of each group.</p>"},{"location":"api/slist/#slist.Slist.map_on_group_values--parameters","title":"Parameters","text":"<p>func : Callable[[Slist[C]], D]     Function to apply to each group's values</p>"},{"location":"api/slist/#slist.Slist.map_on_group_values--returns","title":"Returns","text":"<p>Slist[Group[B, D]]     A new list of groups with transformed values</p>"},{"location":"api/slist/#slist.Slist.map_on_group_values--examples","title":"Examples","text":"<p>groups = Slist([1, 2, 3, 4]).group_by(lambda x: x % 2) groups.map_on_group_values(lambda values: sum(values)) Slist([Group(key=1, values=4), Group(key=0, values=6)])</p> Source code in <code>slist/__init__.py</code> <pre><code>def map_on_group_values(self: Slist[Group[B, Slist[C]]], func: Callable[[Slist[C]], D]) -&gt; Slist[Group[B, D]]:\n    \"\"\"Apply a function to the values of each group.\n\n    Parameters\n    ----------\n    func : Callable[[Slist[C]], D]\n        Function to apply to each group's values\n\n    Returns\n    -------\n    Slist[Group[B, D]]\n        A new list of groups with transformed values\n\n    Examples\n    --------\n    &gt;&gt;&gt; groups = Slist([1, 2, 3, 4]).group_by(lambda x: x % 2)\n    &gt;&gt;&gt; groups.map_on_group_values(lambda values: sum(values))\n    Slist([Group(key=1, values=4), Group(key=0, values=6)])\n    \"\"\"\n    return self.map(lambda group: group.map_values(func))\n</code></pre>"},{"location":"api/slist/#slist.Slist.map_on_group_values_list","title":"map_on_group_values_list","text":"<pre><code>map_on_group_values_list(func: Callable[[B], C]) -&gt; Slist[Group[A, Sequence[C]]]\n</code></pre> <p>Apply a function to each element in each group's values.</p>"},{"location":"api/slist/#slist.Slist.map_on_group_values_list--parameters","title":"Parameters","text":"<p>func : Callable[[B], C]     Function to apply to each element in each group's values</p>"},{"location":"api/slist/#slist.Slist.map_on_group_values_list--returns","title":"Returns","text":"<p>Slist[Group[A, Sequence[C]]]     A new list of groups with transformed elements</p>"},{"location":"api/slist/#slist.Slist.map_on_group_values_list--examples","title":"Examples","text":"<p>groups = Slist([Group(1, [1, 2]), Group(2, [3, 4])]) groups.map_on_group_values_list(lambda x: x * 2) Slist([Group(1, [2, 4]), Group(2, [6, 8])])</p> Source code in <code>slist/__init__.py</code> <pre><code>def map_on_group_values_list(\n    self: Slist[Group[A, Sequence[B]]], func: Callable[[B], C]\n) -&gt; Slist[Group[A, Sequence[C]]]:\n    \"\"\"Apply a function to each element in each group's values.\n\n    Parameters\n    ----------\n    func : Callable[[B], C]\n        Function to apply to each element in each group's values\n\n    Returns\n    -------\n    Slist[Group[A, Sequence[C]]]\n        A new list of groups with transformed elements\n\n    Examples\n    --------\n    &gt;&gt;&gt; groups = Slist([Group(1, [1, 2]), Group(2, [3, 4])])\n    &gt;&gt;&gt; groups.map_on_group_values_list(lambda x: x * 2)\n    Slist([Group(1, [2, 4]), Group(2, [6, 8])])\n    \"\"\"\n    return self.map(lambda group: group.map_values(lambda values: Slist(values).map(func)))\n</code></pre>"},{"location":"api/slist/#slist.Slist.value_counts","title":"value_counts","text":"<pre><code>value_counts(key: Callable[[A], CanHash], sort: bool = True) -&gt; Slist[Group[CanHash, int]]\n</code></pre> <p>Count occurrences of each unique value or key-derived value.</p>"},{"location":"api/slist/#slist.Slist.value_counts--parameters","title":"Parameters","text":"<p>key : Callable[[A], CanHash]     Function to extract the value to count by sort : bool, default=True     If True, sorts the results by count in descending order</p>"},{"location":"api/slist/#slist.Slist.value_counts--returns","title":"Returns","text":"<p>Slist[Group[CanHash, int]]     A list of groups with keys and their counts</p>"},{"location":"api/slist/#slist.Slist.value_counts--examples","title":"Examples","text":"<p>Slist(['apple', 'banana', 'cherry']).value_counts(key=lambda x: x) Slist([Group(key='apple', values=1), Group(key='banana', values=1), Group(key='cherry', values=1)])</p> Source code in <code>slist/__init__.py</code> <pre><code>def value_counts(self, key: Callable[[A], CanHash], sort: bool = True) -&gt; Slist[Group[CanHash, int]]:\n    \"\"\"Count occurrences of each unique value or key-derived value.\n\n    Parameters\n    ----------\n    key : Callable[[A], CanHash]\n        Function to extract the value to count by\n    sort : bool, default=True\n        If True, sorts the results by count in descending order\n\n    Returns\n    -------\n    Slist[Group[CanHash, int]]\n        A list of groups with keys and their counts\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist(['apple', 'banana', 'cherry']).value_counts(key=lambda x: x)\n    Slist([Group(key='apple', values=1), Group(key='banana', values=1), Group(key='cherry', values=1)])\n    \"\"\"\n    result = self.group_by(key).map_on_group_values(len)\n    if sort:\n        return result.sort_by(key=lambda group: group.values, reverse=True)\n    return result\n</code></pre>"},{"location":"api/slist/#slist.Slist.value_percentage","title":"value_percentage","text":"<pre><code>value_percentage(key: Callable[[A], CanHash], sort: bool = True) -&gt; Slist[Group[CanHash, float]]\n</code></pre> <p>Count occurrences of each unique value or key-derived value.</p>"},{"location":"api/slist/#slist.Slist.value_percentage--parameters","title":"Parameters","text":"<p>key : Callable[[A], CanHash]     Function to extract the value to count by sort : bool, default=True     If True, sorts the results by percentage in descending order</p>"},{"location":"api/slist/#slist.Slist.value_percentage--returns","title":"Returns","text":"<p>Slist[Group[CanHash, float]]     A list of groups with keys and their percentage of total</p>"},{"location":"api/slist/#slist.Slist.value_percentage--examples","title":"Examples","text":"<p>Slist(['a', 'a', 'b']).value_percentage(key=lambda x: x) Slist([Group(key='a', values=0.6666666666666666), Group(key='b', values=0.3333333333333333)])</p> Source code in <code>slist/__init__.py</code> <pre><code>def value_percentage(self, key: Callable[[A], CanHash], sort: bool = True) -&gt; Slist[Group[CanHash, float]]:\n    \"\"\"Count occurrences of each unique value or key-derived value.\n\n    Parameters\n    ----------\n    key : Callable[[A], CanHash]\n        Function to extract the value to count by\n    sort : bool, default=True\n        If True, sorts the results by percentage in descending order\n\n    Returns\n    -------\n    Slist[Group[CanHash, float]]\n        A list of groups with keys and their percentage of total\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist(['a', 'a', 'b']).value_percentage(key=lambda x: x)\n    Slist([Group(key='a', values=0.6666666666666666), Group(key='b', values=0.3333333333333333)])\n    \"\"\"\n    total = len(self)\n    if total == 0:\n        return Slist()\n\n    counts = self.value_counts(key, sort=False)\n    result = counts.map(lambda group: Group(key=group.key, values=group.values / total))  # type: ignore\n\n    if sort:\n        return result.sort_by(key=lambda group: group.values, reverse=True)\n    return result\n</code></pre>"},{"location":"api/slist/#slist.Slist.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; Dict[CanHash, B]\n</code></pre> <p>Transforms a Slist of key value pairs to a dictionary</p> <p>Slist([(1, Slist([1, 1])), (2, Slist([2, 2])])).to_dict()</p>"},{"location":"api/slist/#slist.Slist.to_dict--equivalent-to","title":"Equivalent to","text":"<p>Slist([1, 1, 2, 2]).group_by(lambda x: x).to_dict()</p> Source code in <code>slist/__init__.py</code> <pre><code>def to_dict(self: Sequence[Tuple[CanHash, B]]) -&gt; typing.Dict[CanHash, B]:\n    \"\"\"\n    Transforms a Slist of key value pairs to a dictionary\n    &gt;&gt;&gt; Slist([(1, Slist([1, 1])), (2, Slist([2, 2])])).to_dict()\n    # Equivalent to\n    &gt;&gt;&gt; Slist([1, 1, 2, 2]).group_by(lambda x: x).to_dict()\n    {1: Slist([1, 1]), 2: Slist([2, 2])}\n    \"\"\"\n    return dict(self)\n</code></pre>"},{"location":"api/slist/#slist.Slist.to_set","title":"to_set","text":"<pre><code>to_set() -&gt; Set[A]\n</code></pre> <p>Convert the Slist to a set.</p> Source code in <code>slist/__init__.py</code> <pre><code>def to_set(self) -&gt; typing.Set[A]:\n    \"\"\"\n    Convert the Slist to a set.\n    \"\"\"\n    return set(self)\n</code></pre>"},{"location":"api/slist/#slist.Slist.from_dict","title":"from_dict  <code>staticmethod</code>","text":"<pre><code>from_dict(a_dict: Dict[CanHash, A]) -&gt; Slist[Tuple[CanHash, A]]\n</code></pre> <p>Convert a dictionary to a Slist of tuple values.</p>"},{"location":"api/slist/#slist.Slist.from_dict--parameters","title":"Parameters","text":"<p>a_dict : Dict[CanHash, A]     Dictionary to convert</p>"},{"location":"api/slist/#slist.Slist.from_dict--returns","title":"Returns","text":"<p>Slist[Tuple[CanHash, A]]     List of key-value tuples from the dictionary</p>"},{"location":"api/slist/#slist.Slist.from_dict--examples","title":"Examples","text":"<p>Slist.from_dict({1: 'a', 2: 'b'}) Slist([(1, 'a'), (2, 'b')])</p> Source code in <code>slist/__init__.py</code> <pre><code>@staticmethod\ndef from_dict(a_dict: typing.Dict[CanHash, A]) -&gt; Slist[Tuple[CanHash, A]]:\n    \"\"\"Convert a dictionary to a Slist of tuple values.\n\n    Parameters\n    ----------\n    a_dict : Dict[CanHash, A]\n        Dictionary to convert\n\n    Returns\n    -------\n    Slist[Tuple[CanHash, A]]\n        List of key-value tuples from the dictionary\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist.from_dict({1: 'a', 2: 'b'})\n    Slist([(1, 'a'), (2, 'b')])\n    \"\"\"\n    return Slist(tup for tup in a_dict.items())\n</code></pre>"},{"location":"api/slist/#slist.Slist.for_each_enumerate","title":"for_each_enumerate","text":"<pre><code>for_each_enumerate(func: Callable[[int, A], None]) -&gt; Slist[A]\n</code></pre> <p>Apply a side-effect function to each element with its index.</p>"},{"location":"api/slist/#slist.Slist.for_each_enumerate--parameters","title":"Parameters","text":"<p>func : Callable[[int, A], None]     Function taking an index and value, applied for side effects</p>"},{"location":"api/slist/#slist.Slist.for_each_enumerate--returns","title":"Returns","text":"<p>Slist[A]     The original list, unchanged</p>"},{"location":"api/slist/#slist.Slist.for_each_enumerate--examples","title":"Examples","text":"<p>nums = Slist(['a', 'b', 'c']) nums.for_each_enumerate(lambda i, x: print(f\"{i}: {x}\")) 0: a 1: b 2: c nums  # Original list is unchanged Slist(['a', 'b', 'c'])</p> Source code in <code>slist/__init__.py</code> <pre><code>def for_each_enumerate(self, func: Callable[[int, A], None]) -&gt; Slist[A]:\n    \"\"\"Apply a side-effect function to each element with its index.\n\n    Parameters\n    ----------\n    func : Callable[[int, A], None]\n        Function taking an index and value, applied for side effects\n\n    Returns\n    -------\n    Slist[A]\n        The original list, unchanged\n\n    Examples\n    --------\n    &gt;&gt;&gt; nums = Slist(['a', 'b', 'c'])\n    &gt;&gt;&gt; nums.for_each_enumerate(lambda i, x: print(f\"{i}: {x}\"))\n    0: a\n    1: b\n    2: c\n    &gt;&gt;&gt; nums  # Original list is unchanged\n    Slist(['a', 'b', 'c'])\n    \"\"\"\n    for idx, item in enumerate(self):\n        func(idx, item)\n    return self\n</code></pre>"},{"location":"api/slist/#slist.Slist.max_option","title":"max_option","text":"<pre><code>max_option() -&gt; Optional[CanCompare]\n</code></pre> <p>Get the maximum element if it exists.</p>"},{"location":"api/slist/#slist.Slist.max_option--returns","title":"Returns","text":"<p>Optional[CanCompare]     Maximum element, or None if list is empty</p>"},{"location":"api/slist/#slist.Slist.max_option--examples","title":"Examples","text":"<p>Slist([1, 3, 2]).max_option() 3 Slist([]).max_option() None</p> Source code in <code>slist/__init__.py</code> <pre><code>def max_option(self: Sequence[CanCompare]) -&gt; Optional[CanCompare]:\n    \"\"\"Get the maximum element if it exists.\n\n    Returns\n    -------\n    Optional[CanCompare]\n        Maximum element, or None if list is empty\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 3, 2]).max_option()\n    3\n    &gt;&gt;&gt; Slist([]).max_option()\n    None\n    \"\"\"\n    return max(self) if self else None\n</code></pre>"},{"location":"api/slist/#slist.Slist.max_by","title":"max_by","text":"<pre><code>max_by(key: Callable[[A], CanCompare]) -&gt; Optional[A]\n</code></pre> <p>Get the element with maximum value by key function.</p>"},{"location":"api/slist/#slist.Slist.max_by--parameters","title":"Parameters","text":"<p>key : Callable[[A], CanCompare]     Function to compute comparison value for each element</p>"},{"location":"api/slist/#slist.Slist.max_by--returns","title":"Returns","text":"<p>Optional[A]     Element with maximum key value, or None if list is empty</p>"},{"location":"api/slist/#slist.Slist.max_by--examples","title":"Examples","text":"<p>Slist(['a', 'bbb', 'cc']).max_by(len) 'bbb' Slist([]).max_by(len) None</p> Source code in <code>slist/__init__.py</code> <pre><code>def max_by(self, key: Callable[[A], CanCompare]) -&gt; Optional[A]:\n    \"\"\"Get the element with maximum value by key function.\n\n    Parameters\n    ----------\n    key : Callable[[A], CanCompare]\n        Function to compute comparison value for each element\n\n    Returns\n    -------\n    Optional[A]\n        Element with maximum key value, or None if list is empty\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist(['a', 'bbb', 'cc']).max_by(len)\n    'bbb'\n    &gt;&gt;&gt; Slist([]).max_by(len)\n    None\n    \"\"\"\n    return max(self, key=key) if self.length &gt; 0 else None\n</code></pre>"},{"location":"api/slist/#slist.Slist.max_by_ordering","title":"max_by_ordering","text":"<pre><code>max_by_ordering(ordering: Callable[[A, A], bool]) -&gt; Optional[A]\n</code></pre> <p>Get maximum element using custom ordering function.</p>"},{"location":"api/slist/#slist.Slist.max_by_ordering--parameters","title":"Parameters","text":"<p>ordering : Callable[[A, A], bool]     Function that returns True if first argument should be considered larger</p>"},{"location":"api/slist/#slist.Slist.max_by_ordering--returns","title":"Returns","text":"<p>Optional[A]     Maximum element by ordering, or None if list is empty</p>"},{"location":"api/slist/#slist.Slist.max_by_ordering--examples","title":"Examples","text":"Source code in <code>slist/__init__.py</code> <pre><code>def max_by_ordering(self, ordering: Callable[[A, A], bool]) -&gt; Optional[A]:\n    \"\"\"Get maximum element using custom ordering function.\n\n    Parameters\n    ----------\n    ordering : Callable[[A, A], bool]\n        Function that returns True if first argument should be considered larger\n\n    Returns\n    -------\n    Optional[A]\n        Maximum element by ordering, or None if list is empty\n\n    Examples\n    --------\n    &gt;&gt;&gt; # Custom ordering: consider numbers closer to 10 as \"larger\"\n    &gt;&gt;&gt; nums = Slist([1, 5, 8, 15])\n    &gt;&gt;&gt; nums.max_by_ordering(lambda x, y: abs(x-10) &lt; abs(y-10))\n    8\n    \"\"\"\n    theMax: Optional[A] = self.first_option\n    for currentItem in self:\n        if theMax is not None:\n            if ordering(theMax, currentItem):\n                theMax = currentItem\n    return theMax\n</code></pre>"},{"location":"api/slist/#slist.Slist.max_by_ordering--custom-ordering-consider-numbers-closer-to-10-as-larger","title":"Custom ordering: consider numbers closer to 10 as \"larger\"","text":"<p>nums = Slist([1, 5, 8, 15]) nums.max_by_ordering(lambda x, y: abs(x-10) &lt; abs(y-10)) 8</p>"},{"location":"api/slist/#slist.Slist.min_option","title":"min_option","text":"<pre><code>min_option() -&gt; Optional[CanCompare]\n</code></pre> <p>Get the minimum element if it exists.</p>"},{"location":"api/slist/#slist.Slist.min_option--returns","title":"Returns","text":"<p>Optional[CanCompare]     Minimum element, or None if list is empty</p>"},{"location":"api/slist/#slist.Slist.min_option--examples","title":"Examples","text":"<p>Slist([3, 1, 2]).min_option() 1 Slist([]).min_option() None</p> Source code in <code>slist/__init__.py</code> <pre><code>def min_option(self: Sequence[CanCompare]) -&gt; Optional[CanCompare]:\n    \"\"\"Get the minimum element if it exists.\n\n    Returns\n    -------\n    Optional[CanCompare]\n        Minimum element, or None if list is empty\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([3, 1, 2]).min_option()\n    1\n    &gt;&gt;&gt; Slist([]).min_option()\n    None\n    \"\"\"\n    return min(self) if self else None\n</code></pre>"},{"location":"api/slist/#slist.Slist.min_by","title":"min_by","text":"<pre><code>min_by(key: Callable[[A], CanCompare]) -&gt; Optional[A]\n</code></pre> <p>Get the element with minimum value by key function.</p>"},{"location":"api/slist/#slist.Slist.min_by--parameters","title":"Parameters","text":"<p>key : Callable[[A], CanCompare]     Function to compute comparison value for each element</p>"},{"location":"api/slist/#slist.Slist.min_by--returns","title":"Returns","text":"<p>Optional[A]     Element with minimum key value, or None if list is empty</p>"},{"location":"api/slist/#slist.Slist.min_by--examples","title":"Examples","text":"<p>Slist(['aaa', 'b', 'cc']).min_by(len) 'b' Slist([]).min_by(len) None</p> Source code in <code>slist/__init__.py</code> <pre><code>def min_by(self, key: Callable[[A], CanCompare]) -&gt; Optional[A]:\n    \"\"\"Get the element with minimum value by key function.\n\n    Parameters\n    ----------\n    key : Callable[[A], CanCompare]\n        Function to compute comparison value for each element\n\n    Returns\n    -------\n    Optional[A]\n        Element with minimum key value, or None if list is empty\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist(['aaa', 'b', 'cc']).min_by(len)\n    'b'\n    &gt;&gt;&gt; Slist([]).min_by(len)\n    None\n    \"\"\"\n    return min(self, key=key) if self.length &gt; 0 else None\n</code></pre>"},{"location":"api/slist/#slist.Slist.min_by_ordering","title":"min_by_ordering","text":"<pre><code>min_by_ordering() -&gt; Optional[CanCompare]\n</code></pre> <p>Get minimum element using default ordering.</p>"},{"location":"api/slist/#slist.Slist.min_by_ordering--returns","title":"Returns","text":"<p>Optional[CanCompare]     Minimum element, or None if list is empty</p>"},{"location":"api/slist/#slist.Slist.min_by_ordering--examples","title":"Examples","text":"<p>Slist([3, 1, 2]).min_by_ordering() 1 Slist([]).min_by_ordering() None</p> Source code in <code>slist/__init__.py</code> <pre><code>def min_by_ordering(self: Slist[CanCompare]) -&gt; Optional[CanCompare]:\n    \"\"\"Get minimum element using default ordering.\n\n    Returns\n    -------\n    Optional[CanCompare]\n        Minimum element, or None if list is empty\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([3, 1, 2]).min_by_ordering()\n    1\n    &gt;&gt;&gt; Slist([]).min_by_ordering()\n    None\n    \"\"\"\n    return min(self) if self else None\n</code></pre>"},{"location":"api/slist/#slist.Slist.get","title":"get","text":"<pre><code>get(index: int, or_else: B) -&gt; Union[A, B]\n</code></pre> <p>Get element at index with fallback value.</p>"},{"location":"api/slist/#slist.Slist.get--parameters","title":"Parameters","text":"<p>index : int     Index to get element from or_else : B     Value to return if index is out of bounds</p>"},{"location":"api/slist/#slist.Slist.get--returns","title":"Returns","text":"<p>Union[A, B]     Element at index if it exists, otherwise or_else value</p>"},{"location":"api/slist/#slist.Slist.get--examples","title":"Examples","text":"<p>Slist([1, 2, 3]).get(1, -1) 2 Slist([1, 2, 3]).get(5, -1) -1</p> Source code in <code>slist/__init__.py</code> <pre><code>def get(self, index: int, or_else: B) -&gt; Union[A, B]:\n    \"\"\"Get element at index with fallback value.\n\n    Parameters\n    ----------\n    index : int\n        Index to get element from\n    or_else : B\n        Value to return if index is out of bounds\n\n    Returns\n    -------\n    Union[A, B]\n        Element at index if it exists, otherwise or_else value\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3]).get(1, -1)\n    2\n    &gt;&gt;&gt; Slist([1, 2, 3]).get(5, -1)\n    -1\n    \"\"\"\n    try:\n        return self.__getitem__(index)\n    except IndexError:\n        return or_else\n</code></pre>"},{"location":"api/slist/#slist.Slist.get_option","title":"get_option","text":"<pre><code>get_option(index: int) -&gt; Optional[A]\n</code></pre> <p>Get element at index if it exists.</p>"},{"location":"api/slist/#slist.Slist.get_option--parameters","title":"Parameters","text":"<p>index : int     Index to get element from</p>"},{"location":"api/slist/#slist.Slist.get_option--returns","title":"Returns","text":"<p>Optional[A]     Element at index if it exists, otherwise None</p>"},{"location":"api/slist/#slist.Slist.get_option--examples","title":"Examples","text":"<p>Slist([1, 2, 3]).get_option(1) 2 Slist([1, 2, 3]).get_option(5) None</p> Source code in <code>slist/__init__.py</code> <pre><code>def get_option(self, index: int) -&gt; Optional[A]:\n    \"\"\"Get element at index if it exists.\n\n    Parameters\n    ----------\n    index : int\n        Index to get element from\n\n    Returns\n    -------\n    Optional[A]\n        Element at index if it exists, otherwise None\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3]).get_option(1)\n    2\n    &gt;&gt;&gt; Slist([1, 2, 3]).get_option(5)\n    None\n    \"\"\"\n    try:\n        return self.__getitem__(index)\n    except IndexError:\n        return None\n</code></pre>"},{"location":"api/slist/#slist.Slist.pairwise","title":"pairwise","text":"<pre><code>pairwise() -&gt; Slist[Tuple[A, A]]\n</code></pre> <p>Return overlapping pairs of consecutive elements.</p>"},{"location":"api/slist/#slist.Slist.pairwise--returns","title":"Returns","text":"<p>Slist[Tuple[A, A]]     List of tuples containing consecutive overlapping pairs</p>"},{"location":"api/slist/#slist.Slist.pairwise--examples","title":"Examples","text":"<p>Slist([1, 2, 3, 4]).pairwise() Slist([(1, 2), (2, 3), (3, 4)]) Slist([1]).pairwise() Slist([]) Slist([]).pairwise() Slist([])</p>"},{"location":"api/slist/#slist.Slist.pairwise--notes","title":"Notes","text":"<p>Inspired by more-itertools pairwise function. Creates an iterator of overlapping pairs from the input sequence.</p> Source code in <code>slist/__init__.py</code> <pre><code>def pairwise(self) -&gt; Slist[Tuple[A, A]]:\n    \"\"\"Return overlapping pairs of consecutive elements.\n\n    Returns\n    -------\n    Slist[Tuple[A, A]]\n        List of tuples containing consecutive overlapping pairs\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3, 4]).pairwise()\n    Slist([(1, 2), (2, 3), (3, 4)])\n    &gt;&gt;&gt; Slist([1]).pairwise()\n    Slist([])\n    &gt;&gt;&gt; Slist([]).pairwise()\n    Slist([])\n\n    Notes\n    -----\n    Inspired by more-itertools pairwise function. Creates an iterator of\n    overlapping pairs from the input sequence.\n    \"\"\"\n    a, b = tee(self)\n    next(b, None)\n    return Slist(zip(a, b))\n</code></pre>"},{"location":"api/slist/#slist.Slist.print_length","title":"print_length","text":"<pre><code>print_length(printer: Callable[[str], None] = print, prefix: str = 'Slist Length: ') -&gt; Slist[A]\n</code></pre> <p>Print the length of the list and return the original list.</p>"},{"location":"api/slist/#slist.Slist.print_length--parameters","title":"Parameters","text":"<p>printer : Callable[[str], None], optional     Function to print the output, by default print prefix : str, optional     Prefix string before the length, by default \"Slist Length: \"</p>"},{"location":"api/slist/#slist.Slist.print_length--returns","title":"Returns","text":"<p>Slist[A]     The original list unchanged</p>"},{"location":"api/slist/#slist.Slist.print_length--examples","title":"Examples","text":"<p>Slist([1,2,3]).print_length() Slist Length: 3 Slist([1, 2, 3])</p> Source code in <code>slist/__init__.py</code> <pre><code>def print_length(self, printer: Callable[[str], None] = print, prefix: str = \"Slist Length: \") -&gt; Slist[A]:\n    \"\"\"Print the length of the list and return the original list.\n\n    Parameters\n    ----------\n    printer : Callable[[str], None], optional\n        Function to print the output, by default print\n    prefix : str, optional\n        Prefix string before the length, by default \"Slist Length: \"\n\n    Returns\n    -------\n    Slist[A]\n        The original list unchanged\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1,2,3]).print_length()\n    Slist Length: 3\n    Slist([1, 2, 3])\n    \"\"\"\n    string = f\"{prefix}{len(self)}\"\n    printer(string)\n    return self\n</code></pre>"},{"location":"api/slist/#slist.Slist.mode_or_raise","title":"mode_or_raise","text":"<pre><code>mode_or_raise(exception: Exception = RuntimeError('List is empty')) -&gt; A\n</code></pre> <p>Get the most common element or raise an exception.</p>"},{"location":"api/slist/#slist.Slist.mode_or_raise--parameters","title":"Parameters","text":"<p>exception : Exception, optional     Exception to raise if no mode exists, by default RuntimeError(\"List is empty\")</p>"},{"location":"api/slist/#slist.Slist.mode_or_raise--returns","title":"Returns","text":"<p>A     Most frequent element</p>"},{"location":"api/slist/#slist.Slist.mode_or_raise--raises","title":"Raises","text":"<p>Exception     If list is empty or has no unique mode</p>"},{"location":"api/slist/#slist.Slist.mode_or_raise--examples","title":"Examples","text":"<p>Slist([1, 2, 2, 3]).mode_or_raise() 2 try: ...     Slist([]).mode_or_raise() ... except RuntimeError as e: ...     print(str(e)) List is empty</p> Source code in <code>slist/__init__.py</code> <pre><code>def mode_or_raise(self, exception: Exception = RuntimeError(\"List is empty\")) -&gt; A:\n    \"\"\"Get the most common element or raise an exception.\n\n    Parameters\n    ----------\n    exception : Exception, optional\n        Exception to raise if no mode exists, by default RuntimeError(\"List is empty\")\n\n    Returns\n    -------\n    A\n        Most frequent element\n\n    Raises\n    ------\n    Exception\n        If list is empty or has no unique mode\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 2, 3]).mode_or_raise()\n    2\n    &gt;&gt;&gt; try:\n    ...     Slist([]).mode_or_raise()\n    ... except RuntimeError as e:\n    ...     print(str(e))\n    List is empty\n    \"\"\"\n    try:\n        return statistics.mode(self)\n    except statistics.StatisticsError:\n        raise exception\n</code></pre>"},{"location":"api/slist/#slist.Slist.first_or_raise","title":"first_or_raise","text":"<pre><code>first_or_raise(exception: Exception = RuntimeError('List is empty')) -&gt; A\n</code></pre> <p>Get the first element or raise an exception.</p>"},{"location":"api/slist/#slist.Slist.first_or_raise--parameters","title":"Parameters","text":"<p>exception : Exception, optional     Exception to raise if list is empty, by default RuntimeError(\"List is empty\")</p>"},{"location":"api/slist/#slist.Slist.first_or_raise--returns","title":"Returns","text":"<p>A     First element</p>"},{"location":"api/slist/#slist.Slist.first_or_raise--raises","title":"Raises","text":"<p>Exception     If list is empty</p>"},{"location":"api/slist/#slist.Slist.first_or_raise--examples","title":"Examples","text":"<p>Slist([1, 2, 3]).first_or_raise() 1 try: ...     Slist([]).first_or_raise() ... except RuntimeError as e: ...     print(str(e)) List is empty</p> Source code in <code>slist/__init__.py</code> <pre><code>def first_or_raise(self, exception: Exception = RuntimeError(\"List is empty\")) -&gt; A:\n    \"\"\"Get the first element or raise an exception.\n\n    Parameters\n    ----------\n    exception : Exception, optional\n        Exception to raise if list is empty, by default RuntimeError(\"List is empty\")\n\n    Returns\n    -------\n    A\n        First element\n\n    Raises\n    ------\n    Exception\n        If list is empty\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3]).first_or_raise()\n    1\n    &gt;&gt;&gt; try:\n    ...     Slist([]).first_or_raise()\n    ... except RuntimeError as e:\n    ...     print(str(e))\n    List is empty\n    \"\"\"\n    try:\n        return self.__getitem__(0)\n    except IndexError:\n        raise exception\n</code></pre>"},{"location":"api/slist/#slist.Slist.last_or_raise","title":"last_or_raise","text":"<pre><code>last_or_raise(exception: Exception = RuntimeError('List is empty')) -&gt; A\n</code></pre> <p>Get the last element or raise an exception.</p>"},{"location":"api/slist/#slist.Slist.last_or_raise--parameters","title":"Parameters","text":"<p>exception : Exception, optional     Exception to raise if list is empty, by default RuntimeError(\"List is empty\")</p>"},{"location":"api/slist/#slist.Slist.last_or_raise--returns","title":"Returns","text":"<p>A     Last element</p>"},{"location":"api/slist/#slist.Slist.last_or_raise--raises","title":"Raises","text":"<p>Exception     If list is empty</p>"},{"location":"api/slist/#slist.Slist.last_or_raise--examples","title":"Examples","text":"<p>Slist([1, 2, 3]).last_or_raise() 3 try: ...     Slist([]).last_or_raise() ... except RuntimeError as e: ...     print(str(e)) List is empty</p> Source code in <code>slist/__init__.py</code> <pre><code>def last_or_raise(self, exception: Exception = RuntimeError(\"List is empty\")) -&gt; A:\n    \"\"\"Get the last element or raise an exception.\n\n    Parameters\n    ----------\n    exception : Exception, optional\n        Exception to raise if list is empty, by default RuntimeError(\"List is empty\")\n\n    Returns\n    -------\n    A\n        Last element\n\n    Raises\n    ------\n    Exception\n        If list is empty\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3]).last_or_raise()\n    3\n    &gt;&gt;&gt; try:\n    ...     Slist([]).last_or_raise()\n    ... except RuntimeError as e:\n    ...     print(str(e))\n    List is empty\n    \"\"\"\n    try:\n        return self.__getitem__(-1)\n    except IndexError:\n        raise exception\n</code></pre>"},{"location":"api/slist/#slist.Slist.find_one","title":"find_one","text":"<pre><code>find_one(predicate: Callable[[A], bool]) -&gt; Optional[A]\n</code></pre> <p>Find first element that satisfies a predicate.</p>"},{"location":"api/slist/#slist.Slist.find_one--parameters","title":"Parameters","text":"<p>predicate : Callable[[A], bool]     Function that returns True for the desired element</p>"},{"location":"api/slist/#slist.Slist.find_one--returns","title":"Returns","text":"<p>Optional[A]     First matching element, or None if no match found</p>"},{"location":"api/slist/#slist.Slist.find_one--examples","title":"Examples","text":"<p>Slist([1, 2, 3, 4]).find_one(lambda x: x &gt; 2) 3 Slist([1, 2, 3]).find_one(lambda x: x &gt; 5) None</p> Source code in <code>slist/__init__.py</code> <pre><code>def find_one(self, predicate: Callable[[A], bool]) -&gt; Optional[A]:\n    \"\"\"Find first element that satisfies a predicate.\n\n    Parameters\n    ----------\n    predicate : Callable[[A], bool]\n        Function that returns True for the desired element\n\n    Returns\n    -------\n    Optional[A]\n        First matching element, or None if no match found\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3, 4]).find_one(lambda x: x &gt; 2)\n    3\n    &gt;&gt;&gt; Slist([1, 2, 3]).find_one(lambda x: x &gt; 5)\n    None\n    \"\"\"\n    for item in self:\n        if predicate(item):\n            return item\n    return None\n</code></pre>"},{"location":"api/slist/#slist.Slist.find_one_idx","title":"find_one_idx","text":"<pre><code>find_one_idx(predicate: Callable[[A], bool]) -&gt; Optional[int]\n</code></pre> <p>Find index of first element that satisfies a predicate.</p>"},{"location":"api/slist/#slist.Slist.find_one_idx--parameters","title":"Parameters","text":"<p>predicate : Callable[[A], bool]     Function that returns True for the desired element</p>"},{"location":"api/slist/#slist.Slist.find_one_idx--returns","title":"Returns","text":"<p>Optional[int]     Index of first matching element, or None if no match found</p>"},{"location":"api/slist/#slist.Slist.find_one_idx--examples","title":"Examples","text":"<p>Slist([1, 2, 3, 4]).find_one_idx(lambda x: x &gt; 2) 2 Slist([1, 2, 3]).find_one_idx(lambda x: x &gt; 5) None</p> Source code in <code>slist/__init__.py</code> <pre><code>def find_one_idx(self, predicate: Callable[[A], bool]) -&gt; Optional[int]:\n    \"\"\"Find index of first element that satisfies a predicate.\n\n    Parameters\n    ----------\n    predicate : Callable[[A], bool]\n        Function that returns True for the desired element\n\n    Returns\n    -------\n    Optional[int]\n        Index of first matching element, or None if no match found\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3, 4]).find_one_idx(lambda x: x &gt; 2)\n    2\n    &gt;&gt;&gt; Slist([1, 2, 3]).find_one_idx(lambda x: x &gt; 5)\n    None\n    \"\"\"\n    for idx, item in enumerate(self):\n        if predicate(item):\n            return idx\n    return None\n</code></pre>"},{"location":"api/slist/#slist.Slist.find_last_idx","title":"find_last_idx","text":"<pre><code>find_last_idx(predicate: Callable[[A], bool]) -&gt; Optional[int]\n</code></pre> <p>Find index of last element that satisfies a predicate.</p>"},{"location":"api/slist/#slist.Slist.find_last_idx--parameters","title":"Parameters","text":"<p>predicate : Callable[[A], bool]     Function that returns True for the desired element</p>"},{"location":"api/slist/#slist.Slist.find_last_idx--returns","title":"Returns","text":"<p>Optional[int]     Index of last matching element, or None if no match found</p>"},{"location":"api/slist/#slist.Slist.find_last_idx--examples","title":"Examples","text":"<p>Slist([1, 2, 3, 2, 1]).find_last_idx(lambda x: x == 2) 3 Slist([1, 2, 3]).find_last_idx(lambda x: x &gt; 5) None</p> Source code in <code>slist/__init__.py</code> <pre><code>def find_last_idx(self, predicate: Callable[[A], bool]) -&gt; Optional[int]:\n    \"\"\"Find index of last element that satisfies a predicate.\n\n    Parameters\n    ----------\n    predicate : Callable[[A], bool]\n        Function that returns True for the desired element\n\n    Returns\n    -------\n    Optional[int]\n        Index of last matching element, or None if no match found\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3, 2, 1]).find_last_idx(lambda x: x == 2)\n    3\n    &gt;&gt;&gt; Slist([1, 2, 3]).find_last_idx(lambda x: x &gt; 5)\n    None\n    \"\"\"\n    indexes = []\n    for idx, item in enumerate(self):\n        if predicate(item):\n            indexes.append(idx)\n    return indexes[-1] if indexes else None\n</code></pre>"},{"location":"api/slist/#slist.Slist.find_one_idx_or_raise","title":"find_one_idx_or_raise","text":"<pre><code>find_one_idx_or_raise(predicate: Callable[[A], bool], exception: Exception = RuntimeError('Failed to find predicate')) -&gt; int\n</code></pre> <p>Find index of first element that satisfies a predicate or raise exception.</p>"},{"location":"api/slist/#slist.Slist.find_one_idx_or_raise--parameters","title":"Parameters","text":"<p>predicate : Callable[[A], bool]     Function that returns True for the desired element exception : Exception, optional     Exception to raise if no match found, by default RuntimeError(\"Failed to find predicate\")</p>"},{"location":"api/slist/#slist.Slist.find_one_idx_or_raise--returns","title":"Returns","text":"<p>int     Index of first matching element</p>"},{"location":"api/slist/#slist.Slist.find_one_idx_or_raise--raises","title":"Raises","text":"<p>Exception     If no matching element is found</p>"},{"location":"api/slist/#slist.Slist.find_one_idx_or_raise--examples","title":"Examples","text":"<p>Slist([1, 2, 3, 4]).find_one_idx_or_raise(lambda x: x &gt; 2) 2 try: ...     Slist([1, 2, 3]).find_one_idx_or_raise(lambda x: x &gt; 5) ... except RuntimeError as e: ...     print(str(e)) Failed to find predicate</p> Source code in <code>slist/__init__.py</code> <pre><code>def find_one_idx_or_raise(\n    self,\n    predicate: Callable[[A], bool],\n    exception: Exception = RuntimeError(\"Failed to find predicate\"),\n) -&gt; int:\n    \"\"\"Find index of first element that satisfies a predicate or raise exception.\n\n    Parameters\n    ----------\n    predicate : Callable[[A], bool]\n        Function that returns True for the desired element\n    exception : Exception, optional\n        Exception to raise if no match found, by default RuntimeError(\"Failed to find predicate\")\n\n    Returns\n    -------\n    int\n        Index of first matching element\n\n    Raises\n    ------\n    Exception\n        If no matching element is found\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3, 4]).find_one_idx_or_raise(lambda x: x &gt; 2)\n    2\n    &gt;&gt;&gt; try:\n    ...     Slist([1, 2, 3]).find_one_idx_or_raise(lambda x: x &gt; 5)\n    ... except RuntimeError as e:\n    ...     print(str(e))\n    Failed to find predicate\n    \"\"\"\n    result = self.find_one_idx(predicate=predicate)\n    if result is not None:\n        return result\n    else:\n        raise exception\n</code></pre>"},{"location":"api/slist/#slist.Slist.find_last_idx_or_raise","title":"find_last_idx_or_raise","text":"<pre><code>find_last_idx_or_raise(predicate: Callable[[A], bool], exception: Exception = RuntimeError('Failed to find predicate')) -&gt; int\n</code></pre> <p>Find index of last element that satisfies a predicate or raise exception.</p>"},{"location":"api/slist/#slist.Slist.find_last_idx_or_raise--parameters","title":"Parameters","text":"<p>predicate : Callable[[A], bool]     Function that returns True for the desired element exception : Exception, optional     Exception to raise if no match found, by default RuntimeError(\"Failed to find predicate\")</p>"},{"location":"api/slist/#slist.Slist.find_last_idx_or_raise--returns","title":"Returns","text":"<p>int     Index of last matching element</p>"},{"location":"api/slist/#slist.Slist.find_last_idx_or_raise--raises","title":"Raises","text":"<p>Exception     If no matching element is found</p>"},{"location":"api/slist/#slist.Slist.find_last_idx_or_raise--examples","title":"Examples","text":"<p>Slist([1, 2, 3, 2, 1]).find_last_idx_or_raise(lambda x: x == 2) 3 try: ...     Slist([1, 2, 3]).find_last_idx_or_raise(lambda x: x &gt; 5) ... except RuntimeError as e: ...     print(str(e)) Failed to find predicate</p> Source code in <code>slist/__init__.py</code> <pre><code>def find_last_idx_or_raise(\n    self,\n    predicate: Callable[[A], bool],\n    exception: Exception = RuntimeError(\"Failed to find predicate\"),\n) -&gt; int:\n    \"\"\"Find index of last element that satisfies a predicate or raise exception.\n\n    Parameters\n    ----------\n    predicate : Callable[[A], bool]\n        Function that returns True for the desired element\n    exception : Exception, optional\n        Exception to raise if no match found, by default RuntimeError(\"Failed to find predicate\")\n\n    Returns\n    -------\n    int\n        Index of last matching element\n\n    Raises\n    ------\n    Exception\n        If no matching element is found\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3, 2, 1]).find_last_idx_or_raise(lambda x: x == 2)\n    3\n    &gt;&gt;&gt; try:\n    ...     Slist([1, 2, 3]).find_last_idx_or_raise(lambda x: x &gt; 5)\n    ... except RuntimeError as e:\n    ...     print(str(e))\n    Failed to find predicate\n    \"\"\"\n    result = self.find_last_idx(predicate=predicate)\n    if result is not None:\n        return result\n    else:\n        raise exception\n</code></pre>"},{"location":"api/slist/#slist.Slist.take","title":"take","text":"<pre><code>take(n: int) -&gt; Slist[A]\n</code></pre> Source code in <code>slist/__init__.py</code> <pre><code>def take(self, n: int) -&gt; Slist[A]:\n    return Slist(self[:n])\n</code></pre>"},{"location":"api/slist/#slist.Slist.take_or_raise","title":"take_or_raise","text":"<pre><code>take_or_raise(n: int) -&gt; Slist[A]\n</code></pre> Source code in <code>slist/__init__.py</code> <pre><code>def take_or_raise(self, n: int) -&gt; Slist[A]:\n    # raises if we end up having less elements than n\n    if len(self) &lt; n:\n        raise ValueError(f\"Cannot take {n} elements from a list of length {len(self)}\")\n    return Slist(self[:n])\n</code></pre>"},{"location":"api/slist/#slist.Slist.take_until_exclusive","title":"take_until_exclusive","text":"<pre><code>take_until_exclusive(predicate: Callable[[A], bool]) -&gt; Slist[A]\n</code></pre> <p>Takes the first elements until the predicate is true. Does not include the element that caused the predicate to return true.</p> Source code in <code>slist/__init__.py</code> <pre><code>def take_until_exclusive(self, predicate: Callable[[A], bool]) -&gt; Slist[A]:\n    \"\"\"Takes the first elements until the predicate is true.\n    Does not include the element that caused the predicate to return true.\"\"\"\n    new: Slist[A] = Slist()\n    for x in self:\n        if predicate(x):\n            break\n        else:\n            new.append(x)\n    return new\n</code></pre>"},{"location":"api/slist/#slist.Slist.take_until_inclusive","title":"take_until_inclusive","text":"<pre><code>take_until_inclusive(predicate: Callable[[A], bool]) -&gt; Slist[A]\n</code></pre> <p>Takes the first elements until the predicate is true. Includes the element that caused the predicate to return true.</p> Source code in <code>slist/__init__.py</code> <pre><code>def take_until_inclusive(self, predicate: Callable[[A], bool]) -&gt; Slist[A]:\n    \"\"\"Takes the first elements until the predicate is true.\n    Includes the element that caused the predicate to return true.\"\"\"\n    new: Slist[A] = Slist()\n    for x in self:\n        if predicate(x):\n            new.append(x)\n            break\n        else:\n            new.append(x)\n    return new\n</code></pre>"},{"location":"api/slist/#slist.Slist.sort_by","title":"sort_by","text":"<pre><code>sort_by(key: Callable[[A], CanCompare], reverse: bool = False) -&gt; Slist[A]\n</code></pre> Source code in <code>slist/__init__.py</code> <pre><code>def sort_by(self, key: Callable[[A], CanCompare], reverse: bool = False) -&gt; Slist[A]:\n    new = self.copy()\n    return Slist(sorted(new, key=key, reverse=reverse))\n</code></pre>"},{"location":"api/slist/#slist.Slist.percentile_by","title":"percentile_by","text":"<pre><code>percentile_by(key: Callable[[A], CanCompare], percentile: float) -&gt; A\n</code></pre> <p>Gets the element at the given percentile</p> Source code in <code>slist/__init__.py</code> <pre><code>def percentile_by(self, key: Callable[[A], CanCompare], percentile: float) -&gt; A:\n    \"\"\"Gets the element at the given percentile\"\"\"\n    if percentile &lt; 0 or percentile &gt; 1:\n        raise ValueError(f\"Percentile must be between 0 and 1. Got {percentile}\")\n    if self.length == 0:\n        raise ValueError(\"Cannot get percentile of empty list\")\n    result = self.sort_by(key).get(int(len(self) * percentile), None)\n    assert result is not None\n    return result\n</code></pre>"},{"location":"api/slist/#slist.Slist.median_by","title":"median_by","text":"<pre><code>median_by(key: Callable[[A], CanCompare]) -&gt; A\n</code></pre> <p>Gets the median element</p> Source code in <code>slist/__init__.py</code> <pre><code>def median_by(self, key: Callable[[A], CanCompare]) -&gt; A:\n    \"\"\"Gets the median element\"\"\"\n    if self.length == 0:\n        raise ValueError(\"Cannot get median of empty list\")\n    return self.percentile_by(key, 0.5)\n</code></pre>"},{"location":"api/slist/#slist.Slist.sorted","title":"sorted","text":"<pre><code>sorted(reverse: bool = False) -&gt; Slist[CanCompare]\n</code></pre> Source code in <code>slist/__init__.py</code> <pre><code>def sorted(self: Slist[CanCompare], reverse: bool = False) -&gt; Slist[CanCompare]:\n    return self.sort_by(key=identity, reverse=reverse)\n</code></pre>"},{"location":"api/slist/#slist.Slist.reversed","title":"reversed","text":"<pre><code>reversed() -&gt; Slist[A]\n</code></pre> <p>Returns a new list with the elements in reversed order</p> Source code in <code>slist/__init__.py</code> <pre><code>def reversed(self) -&gt; Slist[A]:\n    \"\"\"Returns a new list with the elements in reversed order\"\"\"\n    return Slist(reversed(self))\n</code></pre>"},{"location":"api/slist/#slist.Slist.sort_by_penalise_duplicates","title":"sort_by_penalise_duplicates","text":"<pre><code>sort_by_penalise_duplicates(sort_key: Callable[[A], CanCompare], duplicate_key: Callable[[A], CanHash], reverse: bool = False) -&gt; Slist[A]\n</code></pre> <p>Sort on a given sort key, but penalises duplicate_key such that they will be at the back of the list</p>"},{"location":"api/slist/#slist.Slist.sort_by_penalise_duplicates--slist6-5-4-3-2-1-1-1sort_by_penalise_duplicatessort_keyidentity-duplicate_keyidentity","title":"&gt;&gt;&gt; Slist([6, 5, 4, 3, 2, 1, 1, 1]).sort_by_penalise_duplicates(sort_key=identity, duplicate_key=identity)","text":"<p>[1, 2, 3, 4, 5, 6, 1, 1]</p> Source code in <code>slist/__init__.py</code> <pre><code>def sort_by_penalise_duplicates(\n    self,\n    sort_key: Callable[[A], CanCompare],\n    duplicate_key: Callable[[A], CanHash],\n    reverse: bool = False,\n) -&gt; Slist[A]:\n    \"\"\"Sort on a given sort key, but penalises duplicate_key such that they will be at the back of the list\n    # &gt;&gt;&gt; Slist([6, 5, 4, 3, 2, 1, 1, 1]).sort_by_penalise_duplicates(sort_key=identity, duplicate_key=identity)\n    [1, 2, 3, 4, 5, 6, 1, 1]\n    \"\"\"\n    non_dupes = Slist[A]()\n    dupes = Slist[A]()\n\n    dupes_tracker: set[CanHash] = set()\n    for item in self:\n        dupe_key = duplicate_key(item)\n        if dupe_key in dupes_tracker:\n            dupes.append(item)\n        else:\n            non_dupes.append(item)\n            dupes_tracker.add(dupe_key)\n\n    return non_dupes.sort_by(key=sort_key, reverse=reverse) + dupes.sort_by(key=sort_key, reverse=reverse)\n</code></pre>"},{"location":"api/slist/#slist.Slist.shuffle_with_penalise_duplicates","title":"shuffle_with_penalise_duplicates","text":"<pre><code>shuffle_with_penalise_duplicates(duplicate_key: Callable[[A], CanHash], seed: Optional[str] = None) -&gt; Slist[A]\n</code></pre> <p>Shuffle, but penalises duplicate_key such that they will be at the back of the list</p>"},{"location":"api/slist/#slist.Slist.shuffle_with_penalise_duplicates--slist6-5-4-3-2-2-1-1-1shuffle_by_penalise_duplicatesduplicate_keyidentity","title":"&gt;&gt;&gt; Slist([6, 5, 4, 3, 2, 2, 1, 1, 1]).shuffle_by_penalise_duplicates(duplicate_key=identity)","text":"<p>[6, 4, 1, 3, 5, 2, 1, 2, 1]</p> Source code in <code>slist/__init__.py</code> <pre><code>def shuffle_with_penalise_duplicates(\n    self,\n    duplicate_key: Callable[[A], CanHash],\n    seed: Optional[str] = None,\n) -&gt; Slist[A]:\n    \"\"\"Shuffle, but penalises duplicate_key such that they will be at the back of the list\n    # &gt;&gt;&gt; Slist([6, 5, 4, 3, 2, 2, 1, 1, 1]).shuffle_by_penalise_duplicates(duplicate_key=identity)\n    [6, 4, 1, 3, 5, 2, 1, 2, 1]\n    \"\"\"\n    non_dupes = Slist[A]()\n    dupes = Slist[A]()\n    shuffled = self.shuffle(seed)\n\n    dupes_tracker: set[CanHash] = set()\n    for item in shuffled:\n        dupe_key = duplicate_key(item)\n        if dupe_key in dupes_tracker:\n            dupes.append(item)\n        else:\n            non_dupes.append(item)\n            dupes_tracker.add(dupe_key)\n\n    return non_dupes.shuffle(seed) + dupes.shuffle(seed)\n</code></pre>"},{"location":"api/slist/#slist.Slist.add","title":"add","text":"<pre><code>add(other: Sequence[B]) -&gt; Slist[Union[A, B]]\n</code></pre> Source code in <code>slist/__init__.py</code> <pre><code>def add(self, other: Sequence[B]) -&gt; Slist[Union[A, B]]:\n    return self + other\n</code></pre>"},{"location":"api/slist/#slist.Slist.add_one","title":"add_one","text":"<pre><code>add_one(other: B) -&gt; Slist[Union[A, B]]\n</code></pre> Source code in <code>slist/__init__.py</code> <pre><code>def add_one(self, other: B) -&gt; Slist[Union[A, B]]:\n    new: Slist[Union[A, B]] = self.copy()  # type: ignore\n    new.append(other)\n    return new\n</code></pre>"},{"location":"api/slist/#slist.Slist.grouped","title":"grouped","text":"<pre><code>grouped(size: int) -&gt; Slist[Slist[A]]\n</code></pre> <p>Groups the list into chunks of size <code>size</code></p> Source code in <code>slist/__init__.py</code> <pre><code>def grouped(self, size: int) -&gt; Slist[Slist[A]]:\n    \"\"\"Groups the list into chunks of size `size`\"\"\"\n    output: Slist[Slist[A]] = Slist()\n    for i in range(0, self.length, size):\n        output.append(self[i : i + size])\n    return output\n</code></pre>"},{"location":"api/slist/#slist.Slist.window","title":"window","text":"<pre><code>window(size: int) -&gt; Slist[Slist[A]]\n</code></pre> <p>Returns a list of windows of size <code>size</code> If the list is too small or empty, returns an empty list Example:</p> <p>Slist([1, 2, 3, 4, 5]).window(3) [[1, 2, 3], [2, 3, 4], [3, 4, 5]]</p> <p>Slist([1]).window(2) []</p> Source code in <code>slist/__init__.py</code> <pre><code>def window(self, size: int) -&gt; Slist[Slist[A]]:\n    \"\"\"Returns a list of windows of size `size`\n    If the list is too small or empty, returns an empty list\n    Example:\n    &gt;&gt;&gt; Slist([1, 2, 3, 4, 5]).window(3)\n    [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\n\n    &gt;&gt;&gt; Slist([1]).window(2)\n    []\n    \"\"\"\n    output: Slist[Slist[A]] = Slist()\n    for i in range(0, self.length - size + 1):\n        output.append(self[i : i + size])\n    return output\n</code></pre>"},{"location":"api/slist/#slist.Slist.distinct","title":"distinct","text":"<pre><code>distinct() -&gt; Slist[CanHash]\n</code></pre> <p>Remove duplicate elements while preserving order.</p>"},{"location":"api/slist/#slist.Slist.distinct--returns","title":"Returns","text":"<p>Slist[CanHash]     A new list with duplicates removed, maintaining original order</p>"},{"location":"api/slist/#slist.Slist.distinct--examples","title":"Examples","text":"<p>Slist([1, 2, 2, 3, 1, 4]).distinct() Slist([1, 2, 3, 4])</p> Source code in <code>slist/__init__.py</code> <pre><code>def distinct(self: Sequence[CanHash]) -&gt; Slist[CanHash]:\n    \"\"\"Remove duplicate elements while preserving order.\n\n    Returns\n    -------\n    Slist[CanHash]\n        A new list with duplicates removed, maintaining original order\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 2, 3, 1, 4]).distinct()\n    Slist([1, 2, 3, 4])\n    \"\"\"\n    seen = set()\n    output = Slist[CanHash]()\n    for item in self:\n        if item in seen:\n            continue\n        else:\n            seen.add(item)\n            output.append(item)\n    return output\n</code></pre>"},{"location":"api/slist/#slist.Slist.distinct_by","title":"distinct_by","text":"<pre><code>distinct_by(key: Callable[[A], CanHash]) -&gt; Slist[A]\n</code></pre> <p>Remove duplicates based on a key function while preserving order.</p>"},{"location":"api/slist/#slist.Slist.distinct_by--parameters","title":"Parameters","text":"<p>key : Callable[[A], CanHash]     Function to compute the unique key for each element</p>"},{"location":"api/slist/#slist.Slist.distinct_by--returns","title":"Returns","text":"<p>Slist[A]     A new list with duplicates removed, maintaining original order</p>"},{"location":"api/slist/#slist.Slist.distinct_by--examples","title":"Examples","text":"<p>data = Slist([(1, 'a'), (2, 'b'), (1, 'c')]) data.distinct_by(lambda x: x[0])  # Distinct by first element Slist([(1, 'a'), (2, 'b')])</p> Source code in <code>slist/__init__.py</code> <pre><code>def distinct_by(self, key: Callable[[A], CanHash]) -&gt; Slist[A]:\n    \"\"\"Remove duplicates based on a key function while preserving order.\n\n    Parameters\n    ----------\n    key : Callable[[A], CanHash]\n        Function to compute the unique key for each element\n\n    Returns\n    -------\n    Slist[A]\n        A new list with duplicates removed, maintaining original order\n\n    Examples\n    --------\n    &gt;&gt;&gt; data = Slist([(1, 'a'), (2, 'b'), (1, 'c')])\n    &gt;&gt;&gt; data.distinct_by(lambda x: x[0])  # Distinct by first element\n    Slist([(1, 'a'), (2, 'b')])\n    \"\"\"\n    seen = set()\n    output = Slist[A]()\n    for item in self:\n        item_hash = key(item)\n        if item_hash in seen:\n            continue\n        else:\n            seen.add(item_hash)\n            output.append(item)\n    return output\n</code></pre>"},{"location":"api/slist/#slist.Slist.distinct_item_or_raise","title":"distinct_item_or_raise","text":"<pre><code>distinct_item_or_raise(key: Callable[[A], CanHash]) -&gt; A\n</code></pre> <p>Get the single unique item by a key function.</p> <p>Raises ValueError if the list is empty or contains multiple distinct items.</p>"},{"location":"api/slist/#slist.Slist.distinct_item_or_raise--parameters","title":"Parameters","text":"<p>key : Callable[[A], CanHash]     Function to compute the unique key for each element</p>"},{"location":"api/slist/#slist.Slist.distinct_item_or_raise--returns","title":"Returns","text":"<p>A     The single unique item</p>"},{"location":"api/slist/#slist.Slist.distinct_item_or_raise--raises","title":"Raises","text":"<p>ValueError     If the list is empty or contains multiple distinct items</p>"},{"location":"api/slist/#slist.Slist.distinct_item_or_raise--examples","title":"Examples","text":"<p>Slist([1, 1, 1]).distinct_item_or_raise(lambda x: x) 1 try: ...     Slist([1, 2, 1]).distinct_item_or_raise(lambda x: x) ... except ValueError as e: ...     print(str(e)) Slist is not distinct [1, 2, 1]</p> Source code in <code>slist/__init__.py</code> <pre><code>def distinct_item_or_raise(self, key: Callable[[A], CanHash]) -&gt; A:\n    \"\"\"Get the single unique item by a key function.\n\n    Raises ValueError if the list is empty or contains multiple distinct items.\n\n    Parameters\n    ----------\n    key : Callable[[A], CanHash]\n        Function to compute the unique key for each element\n\n    Returns\n    -------\n    A\n        The single unique item\n\n    Raises\n    ------\n    ValueError\n        If the list is empty or contains multiple distinct items\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 1, 1]).distinct_item_or_raise(lambda x: x)\n    1\n    &gt;&gt;&gt; try:\n    ...     Slist([1, 2, 1]).distinct_item_or_raise(lambda x: x)\n    ... except ValueError as e:\n    ...     print(str(e))\n    Slist is not distinct [1, 2, 1]\n    \"\"\"\n    if not self:\n        raise ValueError(\"Slist is empty\")\n    distinct = self.distinct_by(key)\n    if len(distinct) != 1:\n        raise ValueError(f\"Slist is not distinct {self}\")\n    return distinct[0]\n</code></pre>"},{"location":"api/slist/#slist.Slist.par_map","title":"par_map","text":"<pre><code>par_map(func: Callable[[A], B], executor: Executor) -&gt; Slist[B]\n</code></pre> <p>Apply a function to each element in parallel using an executor.</p>"},{"location":"api/slist/#slist.Slist.par_map--parameters","title":"Parameters","text":"<p>func : Callable[[A], B]     Function to apply to each element. Must be picklable if using ProcessPoolExecutor executor : concurrent.futures.Executor     The executor to use for parallel execution</p>"},{"location":"api/slist/#slist.Slist.par_map--returns","title":"Returns","text":"<p>Slist[B]     A new list with the results of applying func to each element</p>"},{"location":"api/slist/#slist.Slist.par_map--examples","title":"Examples","text":"<p>from concurrent.futures import ThreadPoolExecutor with ThreadPoolExecutor() as exe: ...     Slist([1, 2, 3]).par_map(lambda x: x * 2, exe) Slist([2, 4, 6])</p>"},{"location":"api/slist/#slist.Slist.par_map--notes","title":"Notes","text":"<p>If using ProcessPoolExecutor, the function must be picklable (e.g., no lambda functions)</p> Source code in <code>slist/__init__.py</code> <pre><code>def par_map(self, func: Callable[[A], B], executor: concurrent.futures.Executor) -&gt; Slist[B]:\n    \"\"\"Apply a function to each element in parallel using an executor.\n\n    Parameters\n    ----------\n    func : Callable[[A], B]\n        Function to apply to each element. Must be picklable if using ProcessPoolExecutor\n    executor : concurrent.futures.Executor\n        The executor to use for parallel execution\n\n    Returns\n    -------\n    Slist[B]\n        A new list with the results of applying func to each element\n\n    Examples\n    --------\n    &gt;&gt;&gt; from concurrent.futures import ThreadPoolExecutor\n    &gt;&gt;&gt; with ThreadPoolExecutor() as exe:\n    ...     Slist([1, 2, 3]).par_map(lambda x: x * 2, exe)\n    Slist([2, 4, 6])\n\n    Notes\n    -----\n    If using ProcessPoolExecutor, the function must be picklable (e.g., no lambda functions)\n    \"\"\"\n    futures: List[concurrent.futures._base.Future[B]] = [executor.submit(func, item) for item in self]\n    results = []\n    for fut in futures:\n        results.append(fut.result())\n    return Slist(results)\n</code></pre>"},{"location":"api/slist/#slist.Slist.par_map_async","title":"par_map_async  <code>async</code>","text":"<pre><code>par_map_async(func: Callable[[A], Awaitable[B]], max_par: int | None = None, tqdm: bool = False) -&gt; Slist[B]\n</code></pre> <p>Asynchronously apply a function to each element with optional parallelism limit.</p>"},{"location":"api/slist/#slist.Slist.par_map_async--parameters","title":"Parameters","text":"<p>func : Callable[[A], Awaitable[B]]     Async function to apply to each element max_par : int | None, optional     Maximum number of parallel operations, by default None tqdm : bool, optional     Whether to show a progress bar, by default False</p>"},{"location":"api/slist/#slist.Slist.par_map_async--returns","title":"Returns","text":"<p>Slist[B]     A new Slist with the transformed elements</p>"},{"location":"api/slist/#slist.Slist.par_map_async--examples","title":"Examples","text":"<p>async def slow_double(x): ...     await asyncio.sleep(0.1) ...     return x * 2 await Slist([1, 2, 3]).par_map_async(slow_double, max_par=2) Slist([2, 4, 6])</p> Source code in <code>slist/__init__.py</code> <pre><code>async def par_map_async(\n    self, func: Callable[[A], typing.Awaitable[B]], max_par: int | None = None, tqdm: bool = False\n) -&gt; Slist[B]:\n    \"\"\"Asynchronously apply a function to each element with optional parallelism limit.\n\n    Parameters\n    ----------\n    func : Callable[[A], Awaitable[B]]\n        Async function to apply to each element\n    max_par : int | None, optional\n        Maximum number of parallel operations, by default None\n    tqdm : bool, optional\n        Whether to show a progress bar, by default False\n\n    Returns\n    -------\n    Slist[B]\n        A new Slist with the transformed elements\n\n    Examples\n    --------\n    &gt;&gt;&gt; async def slow_double(x):\n    ...     await asyncio.sleep(0.1)\n    ...     return x * 2\n    &gt;&gt;&gt; await Slist([1, 2, 3]).par_map_async(slow_double, max_par=2)\n    Slist([2, 4, 6])\n    \"\"\"\n    if max_par is None:\n        if tqdm:\n            import tqdm as tqdm_module\n\n            tqdm_counter = tqdm_module.tqdm(total=len(self))\n\n            async def func_with_tqdm(item: A) -&gt; B:\n                result = await func(item)\n                tqdm_counter.update(1)\n                return result\n\n            return Slist(await asyncio.gather(*[func_with_tqdm(item) for item in self]))\n        else:\n            # todo: clean up branching\n            return Slist(await asyncio.gather(*[func(item) for item in self]))\n\n    else:\n        assert max_par &gt; 0, \"max_par must be greater than 0\"\n        sema = asyncio.Semaphore(max_par)\n        if tqdm:\n            import tqdm as tqdm_module\n\n            tqdm_counter = tqdm_module.tqdm(total=len(self))\n\n            async def func_with_semaphore(item: A) -&gt; B:\n                async with sema:\n                    result = await func(item)\n                    tqdm_counter.update(1)\n                    return result\n\n        else:\n\n            async def func_with_semaphore(item: A) -&gt; B:\n                async with sema:\n                    return await func(item)\n\n        return Slist(await asyncio.gather(*[func_with_semaphore(item) for item in self]))\n</code></pre>"},{"location":"api/slist/#slist.Slist.gather","title":"gather  <code>async</code>","text":"<pre><code>gather() -&gt; Slist[B]\n</code></pre> <p>Gather and await all awaitables in the sequence.</p>"},{"location":"api/slist/#slist.Slist.gather--returns","title":"Returns","text":"<p>Slist[B]     A new Slist containing the awaited results</p>"},{"location":"api/slist/#slist.Slist.gather--examples","title":"Examples","text":"<p>async def slow_value(x): ...     await asyncio.sleep(0.1) ...     return x awaitables = [slow_value(1), slow_value(2), slow_value(3)] await Slist(awaitables).gather() Slist([1, 2, 3])</p> Source code in <code>slist/__init__.py</code> <pre><code>async def gather(self: Sequence[typing.Awaitable[B]]) -&gt; Slist[B]:\n    \"\"\"Gather and await all awaitables in the sequence.\n\n    Returns\n    -------\n    Slist[B]\n        A new Slist containing the awaited results\n\n    Examples\n    --------\n    &gt;&gt;&gt; async def slow_value(x):\n    ...     await asyncio.sleep(0.1)\n    ...     return x\n    &gt;&gt;&gt; awaitables = [slow_value(1), slow_value(2), slow_value(3)]\n    &gt;&gt;&gt; await Slist(awaitables).gather()\n    Slist([1, 2, 3])\n    \"\"\"\n    return Slist(await asyncio.gather(*self))\n</code></pre>"},{"location":"api/slist/#slist.Slist.filter_text_search","title":"filter_text_search","text":"<pre><code>filter_text_search(key: Callable[[A], str], search: List[str]) -&gt; Slist[A]\n</code></pre> <p>Filter items based on text search terms.</p>"},{"location":"api/slist/#slist.Slist.filter_text_search--parameters","title":"Parameters","text":"<p>key : Callable[[A], str]     Function to extract searchable text from each item search : List[str]     List of search terms to match (case-insensitive)</p>"},{"location":"api/slist/#slist.Slist.filter_text_search--returns","title":"Returns","text":"<p>Slist[A]     Items where key text matches any search term</p>"},{"location":"api/slist/#slist.Slist.filter_text_search--examples","title":"Examples","text":"<p>items = Slist(['apple pie', 'banana bread', 'cherry cake']) items.filter_text_search(lambda x: x, ['pie', 'cake']) Slist(['apple pie', 'cherry cake'])</p> Source code in <code>slist/__init__.py</code> <pre><code>def filter_text_search(self, key: Callable[[A], str], search: List[str]) -&gt; Slist[A]:\n    \"\"\"Filter items based on text search terms.\n\n    Parameters\n    ----------\n    key : Callable[[A], str]\n        Function to extract searchable text from each item\n    search : List[str]\n        List of search terms to match (case-insensitive)\n\n    Returns\n    -------\n    Slist[A]\n        Items where key text matches any search term\n\n    Examples\n    --------\n    &gt;&gt;&gt; items = Slist(['apple pie', 'banana bread', 'cherry cake'])\n    &gt;&gt;&gt; items.filter_text_search(lambda x: x, ['pie', 'cake'])\n    Slist(['apple pie', 'cherry cake'])\n    \"\"\"\n\n    def matches_search(text: str) -&gt; bool:\n        if search:\n            search_regex = re.compile(\"|\".join(search), re.IGNORECASE)\n            return bool(re.search(search_regex, text))\n        else:\n            return True  # No filter if search undefined\n\n    return self.filter(predicate=lambda item: matches_search(key(item)))\n</code></pre>"},{"location":"api/slist/#slist.Slist.mk_string","title":"mk_string","text":"<pre><code>mk_string(sep: str) -&gt; str\n</code></pre> <p>Join string elements with a separator.</p>"},{"location":"api/slist/#slist.Slist.mk_string--parameters","title":"Parameters","text":"<p>sep : str     Separator to use between elements</p>"},{"location":"api/slist/#slist.Slist.mk_string--returns","title":"Returns","text":"<p>str     Joined string</p>"},{"location":"api/slist/#slist.Slist.mk_string--examples","title":"Examples","text":"<p>Slist(['a', 'b', 'c']).mk_string(', ') 'a, b, c'</p> Source code in <code>slist/__init__.py</code> <pre><code>def mk_string(self: Sequence[str], sep: str) -&gt; str:\n    \"\"\"Join string elements with a separator.\n\n    Parameters\n    ----------\n    sep : str\n        Separator to use between elements\n\n    Returns\n    -------\n    str\n        Joined string\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist(['a', 'b', 'c']).mk_string(', ')\n    'a, b, c'\n    \"\"\"\n    return sep.join(self)\n</code></pre>"},{"location":"api/slist/#slist.Slist.sum","title":"sum","text":"<pre><code>sum() -&gt; int\n</code></pre><pre><code>sum() -&gt; float\n</code></pre> <pre><code>sum() -&gt; Union[int, float]\n</code></pre> <p>Returns 0 when the list is empty</p> Source code in <code>slist/__init__.py</code> <pre><code>def sum(\n    self: Sequence[Union[int, float, bool]],\n) -&gt; Union[int, float]:\n    \"\"\"Returns 0 when the list is empty\"\"\"\n    return sum(self)\n</code></pre>"},{"location":"api/slist/#slist.Slist.average","title":"average","text":"<pre><code>average() -&gt; Optional[float]\n</code></pre> <p>Calculate the arithmetic mean of numeric values.</p>"},{"location":"api/slist/#slist.Slist.average--returns","title":"Returns","text":"<p>Optional[float]     The average of all values, or None if the list is empty</p>"},{"location":"api/slist/#slist.Slist.average--examples","title":"Examples","text":"<p>Slist([1, 2, 3, 4]).average() 2.5 Slist([]).average() None</p> Source code in <code>slist/__init__.py</code> <pre><code>def average(\n    self: Sequence[Union[int, float, bool]],\n) -&gt; Optional[float]:\n    \"\"\"Calculate the arithmetic mean of numeric values.\n\n    Returns\n    -------\n    Optional[float]\n        The average of all values, or None if the list is empty\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3, 4]).average()\n    2.5\n    &gt;&gt;&gt; Slist([]).average()\n    None\n    \"\"\"\n    this = typing.cast(Slist[Union[int, float, bool]], self)\n    return this.sum() / this.length if this.length &gt; 0 else None\n</code></pre>"},{"location":"api/slist/#slist.Slist.average_or_raise","title":"average_or_raise","text":"<pre><code>average_or_raise() -&gt; float\n</code></pre> <p>Calculate the arithmetic mean of numeric values.</p>"},{"location":"api/slist/#slist.Slist.average_or_raise--returns","title":"Returns","text":"<p>float     The average of all values</p>"},{"location":"api/slist/#slist.Slist.average_or_raise--raises","title":"Raises","text":"<p>ValueError     If the list is empty</p>"},{"location":"api/slist/#slist.Slist.average_or_raise--examples","title":"Examples","text":"<p>Slist([1, 2, 3, 4]).average_or_raise() 2.5 try: ...     Slist([]).average_or_raise() ... except ValueError as e: ...     print(str(e)) Cannot get average of empty list</p> Source code in <code>slist/__init__.py</code> <pre><code>def average_or_raise(\n    self: Sequence[Union[int, float, bool]],\n) -&gt; float:\n    \"\"\"Calculate the arithmetic mean of numeric values.\n\n    Returns\n    -------\n    float\n        The average of all values\n\n    Raises\n    ------\n    ValueError\n        If the list is empty\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3, 4]).average_or_raise()\n    2.5\n    &gt;&gt;&gt; try:\n    ...     Slist([]).average_or_raise()\n    ... except ValueError as e:\n    ...     print(str(e))\n    Cannot get average of empty list\n    \"\"\"\n    this = typing.cast(Slist[Union[int, float, bool]], self)\n    if this.length == 0:\n        raise ValueError(\"Cannot get average of empty list\")\n    return this.sum() / this.length\n</code></pre>"},{"location":"api/slist/#slist.Slist.statistics_or_raise","title":"statistics_or_raise","text":"<pre><code>statistics_or_raise() -&gt; AverageStats\n</code></pre> <p>Calculate comprehensive statistics for numeric values.</p>"},{"location":"api/slist/#slist.Slist.statistics_or_raise--returns","title":"Returns","text":"<p>AverageStats     Statistics including mean, standard deviation, and confidence intervals</p>"},{"location":"api/slist/#slist.Slist.statistics_or_raise--raises","title":"Raises","text":"<p>ValueError     If the list is empty</p>"},{"location":"api/slist/#slist.Slist.statistics_or_raise--examples","title":"Examples","text":"<p>stats = Slist([1, 2, 3, 4, 5]).statistics_or_raise() round(stats.average, 2) 3.0 round(stats.standard_deviation, 2) 1.58</p> Source code in <code>slist/__init__.py</code> <pre><code>def statistics_or_raise(\n    self: Sequence[Union[int, float, bool]],\n) -&gt; AverageStats:\n    \"\"\"Calculate comprehensive statistics for numeric values.\n\n    Returns\n    -------\n    AverageStats\n        Statistics including mean, standard deviation, and confidence intervals\n\n    Raises\n    ------\n    ValueError\n        If the list is empty\n\n    Examples\n    --------\n    &gt;&gt;&gt; stats = Slist([1, 2, 3, 4, 5]).statistics_or_raise()\n    &gt;&gt;&gt; round(stats.average, 2)\n    3.0\n    &gt;&gt;&gt; round(stats.standard_deviation, 2)\n    1.58\n    \"\"\"\n    this = typing.cast(Slist[Union[int, float, bool]], self)\n    if this.length == 0:\n        raise ValueError(\"Cannot get average of empty list\")\n    average = this.average_or_raise()\n    standard_deviation = this.standard_deviation()\n    assert standard_deviation is not None\n    standard_error = standard_deviation / ((this.length) ** 0.5)\n    upper_ci = average + 1.96 * standard_error\n    lower_ci = average - 1.96 * standard_error\n    average_plus_minus_95 = 1.96 * standard_error\n    return AverageStats(\n        average=average,\n        standard_deviation=standard_deviation,\n        upper_confidence_interval_95=upper_ci,\n        lower_confidence_interval_95=lower_ci,\n        count=this.length,\n        average_plus_minus_95=average_plus_minus_95,\n    )\n</code></pre>"},{"location":"api/slist/#slist.Slist.standard_deviation","title":"standard_deviation","text":"<pre><code>standard_deviation() -&gt; Optional[float]\n</code></pre> <p>Calculate the population standard deviation.</p>"},{"location":"api/slist/#slist.Slist.standard_deviation--returns","title":"Returns","text":"<p>Optional[float]     The standard deviation, or None if the list is empty</p>"},{"location":"api/slist/#slist.Slist.standard_deviation--examples","title":"Examples","text":"<p>round(Slist([1, 2, 3, 4, 5]).standard_deviation(), 2) 1.58 Slist([]).standard_deviation() None</p> Source code in <code>slist/__init__.py</code> <pre><code>def standard_deviation(self: Slist[Union[int, float]]) -&gt; Optional[float]:\n    \"\"\"Calculate the population standard deviation.\n\n    Returns\n    -------\n    Optional[float]\n        The standard deviation, or None if the list is empty\n\n    Examples\n    --------\n    &gt;&gt;&gt; round(Slist([1, 2, 3, 4, 5]).standard_deviation(), 2)\n    1.58\n    &gt;&gt;&gt; Slist([]).standard_deviation()\n    None\n    \"\"\"\n    return statistics.stdev(self) if self.length &gt; 0 else None\n</code></pre>"},{"location":"api/slist/#slist.Slist.standardize","title":"standardize","text":"<pre><code>standardize() -&gt; Slist[float]\n</code></pre> <p>Standardize values to have mean 0 and standard deviation 1.</p>"},{"location":"api/slist/#slist.Slist.standardize--returns","title":"Returns","text":"<p>Slist[float]     Standardized values, or empty list if input is empty</p>"},{"location":"api/slist/#slist.Slist.standardize--examples","title":"Examples","text":"<p>result = Slist([1, 2, 3, 4, 5]).standardize() [round(x, 2) for x in result]  # Rounded for display [-1.26, -0.63, 0.0, 0.63, 1.26]</p> Source code in <code>slist/__init__.py</code> <pre><code>def standardize(self: Slist[Union[int, float]]) -&gt; Slist[float]:\n    \"\"\"Standardize values to have mean 0 and standard deviation 1.\n\n    Returns\n    -------\n    Slist[float]\n        Standardized values, or empty list if input is empty\n\n    Examples\n    --------\n    &gt;&gt;&gt; result = Slist([1, 2, 3, 4, 5]).standardize()\n    &gt;&gt;&gt; [round(x, 2) for x in result]  # Rounded for display\n    [-1.26, -0.63, 0.0, 0.63, 1.26]\n    \"\"\"\n    mean = self.average()\n    sd = self.standard_deviation()\n    return Slist((x - mean) / sd for x in self) if mean is not None and sd is not None else Slist()\n</code></pre>"},{"location":"api/slist/#slist.Slist.fold_left","title":"fold_left","text":"<pre><code>fold_left(acc: B, func: Callable[[B, A], B]) -&gt; B\n</code></pre> <p>Fold left operation (reduce) with initial accumulator.</p>"},{"location":"api/slist/#slist.Slist.fold_left--parameters","title":"Parameters","text":"<p>acc : B     Initial accumulator value func : Callable[[B, A], B]     Function to combine accumulator with each element</p>"},{"location":"api/slist/#slist.Slist.fold_left--returns","title":"Returns","text":"<p>B     Final accumulated value</p>"},{"location":"api/slist/#slist.Slist.fold_left--examples","title":"Examples","text":"<p>Slist([1, 2, 3, 4]).fold_left(0, lambda acc, x: acc + x) 10 Slist(['a', 'b', 'c']).fold_left('', lambda acc, x: acc + x) 'abc'</p> Source code in <code>slist/__init__.py</code> <pre><code>def fold_left(self, acc: B, func: Callable[[B, A], B]) -&gt; B:\n    \"\"\"Fold left operation (reduce) with initial accumulator.\n\n    Parameters\n    ----------\n    acc : B\n        Initial accumulator value\n    func : Callable[[B, A], B]\n        Function to combine accumulator with each element\n\n    Returns\n    -------\n    B\n        Final accumulated value\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3, 4]).fold_left(0, lambda acc, x: acc + x)\n    10\n    &gt;&gt;&gt; Slist(['a', 'b', 'c']).fold_left('', lambda acc, x: acc + x)\n    'abc'\n    \"\"\"\n    return reduce(func, self, acc)\n</code></pre>"},{"location":"api/slist/#slist.Slist.fold_right","title":"fold_right","text":"<pre><code>fold_right(acc: B, func: Callable[[A, B], B]) -&gt; B\n</code></pre> <p>Fold right operation with initial accumulator.</p>"},{"location":"api/slist/#slist.Slist.fold_right--parameters","title":"Parameters","text":"<p>acc : B     Initial accumulator value func : Callable[[A, B], B]     Function to combine each element with accumulator</p>"},{"location":"api/slist/#slist.Slist.fold_right--returns","title":"Returns","text":"<p>B     Final accumulated value</p>"},{"location":"api/slist/#slist.Slist.fold_right--examples","title":"Examples","text":"<p>Slist([1, 2, 3]).fold_right('', lambda x, acc: str(x) + acc) '321'</p> Source code in <code>slist/__init__.py</code> <pre><code>def fold_right(self, acc: B, func: Callable[[A, B], B]) -&gt; B:\n    \"\"\"Fold right operation with initial accumulator.\n\n    Parameters\n    ----------\n    acc : B\n        Initial accumulator value\n    func : Callable[[A, B], B]\n        Function to combine each element with accumulator\n\n    Returns\n    -------\n    B\n        Final accumulated value\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3]).fold_right('', lambda x, acc: str(x) + acc)\n    '321'\n    \"\"\"\n    return reduce(lambda a, b: func(b, a), reversed(self), acc)\n</code></pre>"},{"location":"api/slist/#slist.Slist.sum_option","title":"sum_option","text":"<pre><code>sum_option() -&gt; Optional[CanAdd]\n</code></pre> <p>Sums the elements of the sequence. Returns None if the sequence is empty.</p>"},{"location":"api/slist/#slist.Slist.sum_option--returns","title":"Returns","text":"<p>Optional[CanAdd]     The sum of all elements in the sequence, or None if the sequence is empty</p>"},{"location":"api/slist/#slist.Slist.sum_option--examples","title":"Examples","text":"<p>Slist([1, 2, 3]).sum_option() 6 Slist([]).sum_option() None</p> Source code in <code>slist/__init__.py</code> <pre><code>def sum_option(self: Sequence[CanAdd]) -&gt; Optional[CanAdd]:\n    \"\"\"Sums the elements of the sequence. Returns None if the sequence is empty.\n\n    Returns\n    -------\n    Optional[CanAdd]\n        The sum of all elements in the sequence, or None if the sequence is empty\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3]).sum_option()\n    6\n    &gt;&gt;&gt; Slist([]).sum_option()\n    None\n    \"\"\"\n    return reduce(lambda a, b: a + b, self) if len(self) &gt; 0 else None\n</code></pre>"},{"location":"api/slist/#slist.Slist.sum_or_raise","title":"sum_or_raise","text":"<pre><code>sum_or_raise() -&gt; CanAdd\n</code></pre> <p>Sums the elements of the sequence. Raises an error if the sequence is empty.</p>"},{"location":"api/slist/#slist.Slist.sum_or_raise--returns","title":"Returns","text":"<p>CanAdd     The sum of all elements in the sequence</p>"},{"location":"api/slist/#slist.Slist.sum_or_raise--raises","title":"Raises","text":"<p>AssertionError     If the sequence is empty</p>"},{"location":"api/slist/#slist.Slist.sum_or_raise--examples","title":"Examples","text":"<p>Slist([1, 2, 3]).sum_or_raise() 6 Slist([]).sum_or_raise()  # doctest: +IGNORE_EXCEPTION_DETAIL Traceback (most recent call last): AssertionError: Cannot fold empty list</p> Source code in <code>slist/__init__.py</code> <pre><code>def sum_or_raise(self: Sequence[CanAdd]) -&gt; CanAdd:\n    \"\"\"Sums the elements of the sequence. Raises an error if the sequence is empty.\n\n    Returns\n    -------\n    CanAdd\n        The sum of all elements in the sequence\n\n    Raises\n    ------\n    AssertionError\n        If the sequence is empty\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3]).sum_or_raise()\n    6\n    &gt;&gt;&gt; Slist([]).sum_or_raise()  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    AssertionError: Cannot fold empty list\n    \"\"\"\n    assert len(self) &gt; 0, \"Cannot fold empty list\"\n    return reduce(lambda a, b: a + b, self)\n</code></pre>"},{"location":"api/slist/#slist.Slist.split_by","title":"split_by","text":"<pre><code>split_by(predicate: Callable[[A], bool]) -&gt; Tuple[Slist[A], Slist[A]]\n</code></pre> <p>Split list into two lists based on a predicate. Left list contains items that match the predicate.</p>"},{"location":"api/slist/#slist.Slist.split_by--parameters","title":"Parameters","text":"<p>predicate : Callable[[A], bool]     Function to determine which list each element goes into</p>"},{"location":"api/slist/#slist.Slist.split_by--returns","title":"Returns","text":"<p>Tuple[Slist[A], Slist[A]]     Tuple of (matching elements, non-matching elements)</p>"},{"location":"api/slist/#slist.Slist.split_by--examples","title":"Examples","text":"<p>evens, odds = Slist([1, 2, 3, 4, 5]).split_by(lambda x: x % 2 == 0) evens Slist([2, 4]) odds Slist([1, 3, 5])</p> Source code in <code>slist/__init__.py</code> <pre><code>def split_by(self, predicate: Callable[[A], bool]) -&gt; Tuple[Slist[A], Slist[A]]:\n    \"\"\"Split list into two lists based on a predicate. Left list contains items that match the predicate.\n\n    Parameters\n    ----------\n    predicate : Callable[[A], bool]\n        Function to determine which list each element goes into\n\n    Returns\n    -------\n    Tuple[Slist[A], Slist[A]]\n        Tuple of (matching elements, non-matching elements)\n\n    Examples\n    --------\n    &gt;&gt;&gt; evens, odds = Slist([1, 2, 3, 4, 5]).split_by(lambda x: x % 2 == 0)\n    &gt;&gt;&gt; evens\n    Slist([2, 4])\n    &gt;&gt;&gt; odds\n    Slist([1, 3, 5])\n    \"\"\"\n    left = Slist[A]()\n    right = Slist[A]()\n    for item in self:\n        if predicate(item):\n            left.append(item)\n        else:\n            right.append(item)\n    return left, right\n</code></pre>"},{"location":"api/slist/#slist.Slist.split_on","title":"split_on","text":"<pre><code>split_on(predicate: Callable[[A], bool]) -&gt; Slist[Slist[A]]\n</code></pre> <p>Split list into sublists based on a predicate.</p>"},{"location":"api/slist/#slist.Slist.split_on--returns","title":"Returns","text":"<p>Slist[Slist[A]]     List of sublists</p>"},{"location":"api/slist/#slist.Slist.split_on--examples","title":"Examples","text":"<p>Slist([1, 2, 3, 4, 5]).split_on(lambda x: x % 2 == 0) Slist([Slist([1, 3, 5]), Slist([2, 4])])</p> Source code in <code>slist/__init__.py</code> <pre><code>def split_on(self, predicate: Callable[[A], bool]) -&gt; Slist[Slist[A]]:\n    \"\"\"Split list into sublists based on a predicate.\n\n    Returns\n    -------\n    Slist[Slist[A]]\n        List of sublists\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3, 4, 5]).split_on(lambda x: x % 2 == 0)\n    Slist([Slist([1, 3, 5]), Slist([2, 4])])\n    \"\"\"\n    output: Slist[Slist[A]] = Slist()\n    current = Slist[A]()\n    for item in self:\n        if predicate(item):\n            output.append(current)\n            current = Slist[A]()\n        else:\n            current.append(item)\n    output.append(current)\n    return output\n</code></pre>"},{"location":"api/slist/#slist.Slist.split_proportion","title":"split_proportion","text":"<pre><code>split_proportion(left_proportion: float) -&gt; Tuple[Slist[A], Slist[A]]\n</code></pre> <p>Split list into two parts based on a proportion.</p>"},{"location":"api/slist/#slist.Slist.split_proportion--parameters","title":"Parameters","text":"<p>left_proportion : float     Proportion of elements to include in first list (0 &lt; left_proportion &lt; 1)</p>"},{"location":"api/slist/#slist.Slist.split_proportion--returns","title":"Returns","text":"<p>Tuple[Slist[A], Slist[A]]     Tuple of (first part, second part)</p>"},{"location":"api/slist/#slist.Slist.split_proportion--examples","title":"Examples","text":"<p>first, second = Slist([1, 2, 3, 4, 5]).split_proportion(0.6) first Slist([1, 2, 3]) second Slist([4, 5])</p> Source code in <code>slist/__init__.py</code> <pre><code>def split_proportion(self, left_proportion: float) -&gt; Tuple[Slist[A], Slist[A]]:\n    \"\"\"Split list into two parts based on a proportion.\n\n    Parameters\n    ----------\n    left_proportion : float\n        Proportion of elements to include in first list (0 &lt; left_proportion &lt; 1)\n\n    Returns\n    -------\n    Tuple[Slist[A], Slist[A]]\n        Tuple of (first part, second part)\n\n    Examples\n    --------\n    &gt;&gt;&gt; first, second = Slist([1, 2, 3, 4, 5]).split_proportion(0.6)\n    &gt;&gt;&gt; first\n    Slist([1, 2, 3])\n    &gt;&gt;&gt; second\n    Slist([4, 5])\n    \"\"\"\n    assert 0 &lt; left_proportion &lt; 1, \"left_proportion needs to be between 0 and 1\"\n    left = Slist[A]()\n    right = Slist[A]()\n    for idx, item in enumerate(self):\n        if idx &lt; len(self) * left_proportion:\n            left.append(item)\n        else:\n            right.append(item)\n    return left, right\n</code></pre>"},{"location":"api/slist/#slist.Slist.split_into_n","title":"split_into_n","text":"<pre><code>split_into_n(n: int) -&gt; Slist[Slist[A]]\n</code></pre> <p>Split list into n roughly equal parts.</p>"},{"location":"api/slist/#slist.Slist.split_into_n--parameters","title":"Parameters","text":"<p>n : int     Number of parts to split into (must be positive)</p>"},{"location":"api/slist/#slist.Slist.split_into_n--returns","title":"Returns","text":"<p>Slist[Slist[A]]     List of n sublists of roughly equal size</p>"},{"location":"api/slist/#slist.Slist.split_into_n--examples","title":"Examples","text":"<p>Slist([1, 2, 3, 4, 5]).split_into_n(2) Slist([Slist([1, 3, 5]), Slist([2, 4])])</p> Source code in <code>slist/__init__.py</code> <pre><code>def split_into_n(self, n: int) -&gt; Slist[Slist[A]]:\n    \"\"\"Split list into n roughly equal parts.\n\n    Parameters\n    ----------\n    n : int\n        Number of parts to split into (must be positive)\n\n    Returns\n    -------\n    Slist[Slist[A]]\n        List of n sublists of roughly equal size\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3, 4, 5]).split_into_n(2)\n    Slist([Slist([1, 3, 5]), Slist([2, 4])])\n    \"\"\"\n    assert n &gt; 0, \"n needs to be greater than 0\"\n    output: Slist[Slist[A]] = Slist()\n    for _ in range(n):\n        output.append(Slist[A]())\n    for idx, item in enumerate(self):\n        output[idx % n].append(item)\n    return output\n</code></pre>"},{"location":"api/slist/#slist.Slist.copy","title":"copy","text":"<pre><code>copy() -&gt; Slist[A]\n</code></pre> <p>Create a shallow copy of the list.</p>"},{"location":"api/slist/#slist.Slist.copy--returns","title":"Returns","text":"<p>Slist[A]     A new Slist with the same elements</p>"},{"location":"api/slist/#slist.Slist.copy--examples","title":"Examples","text":"<p>original = Slist([1, 2, 3]) copied = original.copy() copied.append(4) original  # Original is unchanged Slist([1, 2, 3])</p> Source code in <code>slist/__init__.py</code> <pre><code>def copy(self) -&gt; Slist[A]:\n    \"\"\"Create a shallow copy of the list.\n\n    Returns\n    -------\n    Slist[A]\n        A new Slist with the same elements\n\n    Examples\n    --------\n    &gt;&gt;&gt; original = Slist([1, 2, 3])\n    &gt;&gt;&gt; copied = original.copy()\n    &gt;&gt;&gt; copied.append(4)\n    &gt;&gt;&gt; original  # Original is unchanged\n    Slist([1, 2, 3])\n    \"\"\"\n    return Slist(super().copy())\n</code></pre>"},{"location":"api/slist/#slist.Slist.repeat_until_size","title":"repeat_until_size","text":"<pre><code>repeat_until_size(size: int) -&gt; Optional[Slist[A]]\n</code></pre> <p>Repeat the list elements until reaching specified size.</p>"},{"location":"api/slist/#slist.Slist.repeat_until_size--parameters","title":"Parameters","text":"<p>size : int     Target size (must be positive)</p>"},{"location":"api/slist/#slist.Slist.repeat_until_size--returns","title":"Returns","text":"<p>Optional[Slist[A]]     New list with repeated elements, or None if input is empty</p>"},{"location":"api/slist/#slist.Slist.repeat_until_size--examples","title":"Examples","text":"<p>Slist([1, 2]).repeat_until_size(5) Slist([1, 2, 1, 2, 1]) Slist([]).repeat_until_size(3) None</p> Source code in <code>slist/__init__.py</code> <pre><code>def repeat_until_size(self, size: int) -&gt; Optional[Slist[A]]:\n    \"\"\"Repeat the list elements until reaching specified size.\n\n    Parameters\n    ----------\n    size : int\n        Target size (must be positive)\n\n    Returns\n    -------\n    Optional[Slist[A]]\n        New list with repeated elements, or None if input is empty\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2]).repeat_until_size(5)\n    Slist([1, 2, 1, 2, 1])\n    &gt;&gt;&gt; Slist([]).repeat_until_size(3)\n    None\n    \"\"\"\n    assert size &gt; 0, \"size needs to be greater than 0\"\n    if self.is_empty:\n        return None\n    else:\n        new = Slist[A]()\n        while True:\n            for item in self:\n                if len(new) &gt;= size:\n                    return new\n                else:\n                    new.append(item)\n</code></pre>"},{"location":"api/slist/#slist.Slist.repeat_until_size_enumerate","title":"repeat_until_size_enumerate","text":"<pre><code>repeat_until_size_enumerate(size: int) -&gt; Slist[Tuple[int, A]]\n</code></pre> <p>Repeat the list elements until reaching specified size, with enumeration.</p>"},{"location":"api/slist/#slist.Slist.repeat_until_size_enumerate--parameters","title":"Parameters","text":"<p>size : int     Target size (must be positive)</p>"},{"location":"api/slist/#slist.Slist.repeat_until_size_enumerate--returns","title":"Returns","text":"<p>Slist[Tuple[int, A]]     New list with repeated elements and their repetition count</p>"},{"location":"api/slist/#slist.Slist.repeat_until_size_enumerate--raises","title":"Raises","text":"<p>AssertionError     If size is not positive ValueError     If input list is empty</p>"},{"location":"api/slist/#slist.Slist.repeat_until_size_enumerate--examples","title":"Examples","text":"<p>Slist([\"a\", \"b\"]).repeat_until_size_enumerate(5) Slist([(0, 'a'), (0, 'b'), (1, 'a'), (1, 'b'), (2, 'a')])</p> Source code in <code>slist/__init__.py</code> <pre><code>def repeat_until_size_enumerate(self, size: int) -&gt; Slist[Tuple[int, A]]:\n    \"\"\"Repeat the list elements until reaching specified size, with enumeration.\n\n    Parameters\n    ----------\n    size : int\n        Target size (must be positive)\n\n    Returns\n    -------\n    Slist[Tuple[int, A]]\n        New list with repeated elements and their repetition count\n\n    Raises\n    ------\n    AssertionError\n        If size is not positive\n    ValueError\n        If input list is empty\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([\"a\", \"b\"]).repeat_until_size_enumerate(5)\n    Slist([(0, 'a'), (0, 'b'), (1, 'a'), (1, 'b'), (2, 'a')])\n    \"\"\"\n    assert size &gt; 0, \"size needs to be greater than 0\"\n    if self.is_empty:\n        raise ValueError(\"input needs to be non empty\")\n\n    new = Slist[Tuple[int, A]]()\n    repetition_count = 0\n\n    while True:\n        for item in self:\n            if len(new) &gt;= size:\n                return new\n            else:\n                new.append((repetition_count, item))\n        repetition_count += 1\n</code></pre>"},{"location":"api/slist/#slist.Slist.repeat_until_size_or_raise","title":"repeat_until_size_or_raise","text":"<pre><code>repeat_until_size_or_raise(size: int) -&gt; Slist[A]\n</code></pre> <p>Repeat the list elements until reaching specified size.</p>"},{"location":"api/slist/#slist.Slist.repeat_until_size_or_raise--parameters","title":"Parameters","text":"<p>size : int     Target size (must be positive)</p>"},{"location":"api/slist/#slist.Slist.repeat_until_size_or_raise--returns","title":"Returns","text":"<p>Slist[A]     New list with repeated elements</p>"},{"location":"api/slist/#slist.Slist.repeat_until_size_or_raise--raises","title":"Raises","text":"<p>AssertionError     If size is not positive ValueError     If input list is empty</p>"},{"location":"api/slist/#slist.Slist.repeat_until_size_or_raise--examples","title":"Examples","text":"<p>Slist([1, 2]).repeat_until_size_or_raise(5) Slist([1, 2, 1, 2, 1])</p> Source code in <code>slist/__init__.py</code> <pre><code>def repeat_until_size_or_raise(self, size: int) -&gt; Slist[A]:\n    \"\"\"Repeat the list elements until reaching specified size.\n\n    Parameters\n    ----------\n    size : int\n        Target size (must be positive)\n\n    Returns\n    -------\n    Slist[A]\n        New list with repeated elements\n\n    Raises\n    ------\n    AssertionError\n        If size is not positive\n    ValueError\n        If input list is empty\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2]).repeat_until_size_or_raise(5)\n    Slist([1, 2, 1, 2, 1])\n    \"\"\"\n    assert size &gt; 0, \"size needs to be greater than 0\"\n    assert not self.is_empty, \"input needs to be non empty\"\n    new = Slist[A]()\n    while True:\n        for item in self:\n            if len(new) &gt;= size:\n                return new\n            else:\n                new.append(item)\n</code></pre>"},{"location":"api/slist/#slist.Slist.zip","title":"zip","text":"<pre><code>zip(other: Sequence[B]) -&gt; Slist[Tuple[A, B]]\n</code></pre><pre><code>zip(other1: Sequence[B], other2: Sequence[C]) -&gt; Slist[Tuple[A, B, C]]\n</code></pre><pre><code>zip(other1: Sequence[B], other2: Sequence[C], other3: Sequence[D]) -&gt; Slist[Tuple[A, B, C, D]]\n</code></pre><pre><code>zip(other1: Sequence[B], other2: Sequence[C], other3: Sequence[D], other4: Sequence[E]) -&gt; Slist[Tuple[A, B, C, D, E]]\n</code></pre> <pre><code>zip(*others: Sequence[Any]) -&gt; Slist[Tuple[Any, ...]]\n</code></pre> <p>Zip this list with other sequences.</p>"},{"location":"api/slist/#slist.Slist.zip--parameters","title":"Parameters","text":"<p>*others : Sequence[B]     Other sequences to zip with</p>"},{"location":"api/slist/#slist.Slist.zip--returns","title":"Returns","text":"<p>Slist[Tuple[A, *Tuple[B, ...]]]     List of tuples containing elements from all sequences</p>"},{"location":"api/slist/#slist.Slist.zip--raises","title":"Raises","text":"<p>TypeError     If sequences have different lengths</p>"},{"location":"api/slist/#slist.Slist.zip--examples","title":"Examples","text":"<p>Slist([1, 2, 3]).zip(Slist([\"1\", \"2\", \"3\"])) Slist([(1, \"1\"), (2, \"2\"), (3, \"3\")]) Slist([1, 2, 3]).zip(Slist([\"1\", \"2\", \"3\"]), Slist([True, True, True])) Slist([(1, \"1\", True), (2, \"2\", True), (3, \"3\", True)])</p> Source code in <code>slist/__init__.py</code> <pre><code>def zip(self: Sequence[A], *others: Sequence[Any]) -&gt; Slist[Tuple[Any, ...]]:\n    \"\"\"Zip this list with other sequences.\n\n    Parameters\n    ----------\n    *others : Sequence[B]\n        Other sequences to zip with\n\n    Returns\n    -------\n    Slist[Tuple[A, *Tuple[B, ...]]]\n        List of tuples containing elements from all sequences\n\n    Raises\n    ------\n    TypeError\n        If sequences have different lengths\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3]).zip(Slist([\"1\", \"2\", \"3\"]))\n    Slist([(1, \"1\"), (2, \"2\"), (3, \"3\")])\n    &gt;&gt;&gt; Slist([1, 2, 3]).zip(Slist([\"1\", \"2\", \"3\"]), Slist([True, True, True]))\n    Slist([(1, \"1\", True), (2, \"2\", True), (3, \"3\", True)])\n    \"\"\"\n    # Convert to list to check lengths\n    if sys.version_info &gt;= (3, 10):\n        return Slist(zip(self, *others, strict=True))\n    else:\n        return Slist(zip(self, *others))\n</code></pre>"},{"location":"api/slist/#slist.Slist.zip_cycle","title":"zip_cycle","text":"<pre><code>zip_cycle(other: Sequence[B]) -&gt; Slist[Tuple[A, B]]\n</code></pre><pre><code>zip_cycle(other1: Sequence[B], other2: Sequence[C]) -&gt; Slist[Tuple[A, B, C]]\n</code></pre><pre><code>zip_cycle(other1: Sequence[B], other2: Sequence[C], other3: Sequence[D]) -&gt; Slist[Tuple[A, B, C, D]]\n</code></pre><pre><code>zip_cycle(other1: Sequence[B], other2: Sequence[C], other3: Sequence[D], other4: Sequence[E]) -&gt; Slist[Tuple[A, B, C, D, E]]\n</code></pre> <pre><code>zip_cycle(*others: Sequence[Any]) -&gt; Slist[Tuple[Any, ...]]\n</code></pre> <p>Zip sequences by cycling shorter ones until all are exhausted.</p> <p>Unlike regular zip which stops at the shortest sequence, zip_cycle repeats shorter sequences cyclically until the longest sequence is exhausted.</p>"},{"location":"api/slist/#slist.Slist.zip_cycle--parameters","title":"Parameters","text":"<p>*others : Sequence[Any]     Other sequences to zip with</p>"},{"location":"api/slist/#slist.Slist.zip_cycle--returns","title":"Returns","text":"<p>Slist[Tuple[Any, ...]]     List of tuples containing elements from all sequences</p>"},{"location":"api/slist/#slist.Slist.zip_cycle--examples","title":"Examples","text":"<p>Slist([1, 2, 3]).zip_cycle(['a', 'b']) Slist([(1, 'a'), (2, 'b'), (3, 'a')]) Slist([1, 2]).zip_cycle(['a', 'b', 'c', 'd']) Slist([(1, 'a'), (2, 'b'), (1, 'c'), (2, 'd')]) Slist([1, 2, 3]).zip_cycle(['a', 'b'], [10, 20, 30, 40]) Slist([(1, 'a', 10), (2, 'b', 20), (3, 'a', 30), (1, 'b', 40)])</p> Source code in <code>slist/__init__.py</code> <pre><code>def zip_cycle(self: Sequence[A], *others: Sequence[Any]) -&gt; Slist[Tuple[Any, ...]]:\n    \"\"\"Zip sequences by cycling shorter ones until all are exhausted.\n\n    Unlike regular zip which stops at the shortest sequence, zip_cycle\n    repeats shorter sequences cyclically until the longest sequence is exhausted.\n\n    Parameters\n    ----------\n    *others : Sequence[Any]\n        Other sequences to zip with\n\n    Returns\n    -------\n    Slist[Tuple[Any, ...]]\n        List of tuples containing elements from all sequences\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3]).zip_cycle(['a', 'b'])\n    Slist([(1, 'a'), (2, 'b'), (3, 'a')])\n    &gt;&gt;&gt; Slist([1, 2]).zip_cycle(['a', 'b', 'c', 'd'])\n    Slist([(1, 'a'), (2, 'b'), (1, 'c'), (2, 'd')])\n    &gt;&gt;&gt; Slist([1, 2, 3]).zip_cycle(['a', 'b'], [10, 20, 30, 40])\n    Slist([(1, 'a', 10), (2, 'b', 20), (3, 'a', 30), (1, 'b', 40)])\n    \"\"\"\n    all_sequences = [self] + list(others)\n\n    # If any sequence is empty, return empty list\n    if any(len(seq) == 0 for seq in all_sequences):\n        return Slist()\n\n    # Find the maximum length\n    max_len = max(len(seq) for seq in all_sequences)\n\n    # Create cycled iterators for each sequence\n    cycled_iterators = [itertools.cycle(seq) for seq in all_sequences]\n\n    # Zip them together for max_len items\n    result = []\n    for _ in range(max_len):\n        result.append(tuple(next(it) for it in cycled_iterators))\n\n    return Slist(result)\n</code></pre>"},{"location":"api/slist/#slist.Slist.slice_with_bool","title":"slice_with_bool","text":"<pre><code>slice_with_bool(bools: Sequence[bool]) -&gt; Slist[A]\n</code></pre> <p>Slice the list using a sequence of boolean values.</p>"},{"location":"api/slist/#slist.Slist.slice_with_bool--parameters","title":"Parameters","text":"<p>bools : Sequence[bool]     Boolean sequence indicating which elements to keep</p>"},{"location":"api/slist/#slist.Slist.slice_with_bool--returns","title":"Returns","text":"<p>Slist[A]     List containing elements where corresponding boolean is True</p>"},{"location":"api/slist/#slist.Slist.slice_with_bool--examples","title":"Examples","text":"<p>Slist([1, 2, 3, 4, 5]).slice_with_bool([True, False, True, False, True]) Slist([1, 3, 5])</p> Source code in <code>slist/__init__.py</code> <pre><code>def slice_with_bool(self, bools: Sequence[bool]) -&gt; Slist[A]:\n    \"\"\"Slice the list using a sequence of boolean values.\n\n    Parameters\n    ----------\n    bools : Sequence[bool]\n        Boolean sequence indicating which elements to keep\n\n    Returns\n    -------\n    Slist[A]\n        List containing elements where corresponding boolean is True\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3, 4, 5]).slice_with_bool([True, False, True, False, True])\n    Slist([1, 3, 5])\n    \"\"\"\n    return Slist(item for item, keep in zip(self, bools) if keep)\n</code></pre>"},{"location":"api/slist/#slist.Slist.find_one_or_raise","title":"find_one_or_raise","text":"<pre><code>find_one_or_raise(predicate: Callable[[A], bool], exception: Exception = RuntimeError('Failed to find predicate')) -&gt; A\n</code></pre> <p>Find first element that satisfies a predicate or raise exception.</p>"},{"location":"api/slist/#slist.Slist.find_one_or_raise--parameters","title":"Parameters","text":"<p>predicate : Callable[[A], bool]     Function that returns True for the desired element exception : Exception, optional     Exception to raise if no match found, by default RuntimeError(\"Failed to find predicate\")</p>"},{"location":"api/slist/#slist.Slist.find_one_or_raise--returns","title":"Returns","text":"<p>A     First matching element</p>"},{"location":"api/slist/#slist.Slist.find_one_or_raise--raises","title":"Raises","text":"<p>Exception     If no matching element is found</p>"},{"location":"api/slist/#slist.Slist.find_one_or_raise--examples","title":"Examples","text":"<p>Slist([1, 2, 3, 4]).find_one_or_raise(lambda x: x &gt; 3) 4 try: ...     Slist([1, 2, 3]).find_one_or_raise(lambda x: x &gt; 5) ... except RuntimeError as e: ...     print(str(e)) Failed to find predicate</p> Source code in <code>slist/__init__.py</code> <pre><code>def find_one_or_raise(\n    self,\n    predicate: Callable[[A], bool],\n    exception: Exception = RuntimeError(\"Failed to find predicate\"),\n) -&gt; A:\n    \"\"\"Find first element that satisfies a predicate or raise exception.\n\n    Parameters\n    ----------\n    predicate : Callable[[A], bool]\n        Function that returns True for the desired element\n    exception : Exception, optional\n        Exception to raise if no match found, by default RuntimeError(\"Failed to find predicate\")\n\n    Returns\n    -------\n    A\n        First matching element\n\n    Raises\n    ------\n    Exception\n        If no matching element is found\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2, 3, 4]).find_one_or_raise(lambda x: x &gt; 3)\n    4\n    &gt;&gt;&gt; try:\n    ...     Slist([1, 2, 3]).find_one_or_raise(lambda x: x &gt; 5)\n    ... except RuntimeError as e:\n    ...     print(str(e))\n    Failed to find predicate\n    \"\"\"\n    result = self.find_one(predicate)\n    if result is not None:\n        return result\n    else:\n        raise exception\n</code></pre>"},{"location":"api/slist/#slist.Slist.permutations_pairs","title":"permutations_pairs","text":"<pre><code>permutations_pairs() -&gt; Slist[Tuple[A, A]]\n</code></pre> <p>Generate all possible pairs of elements, including reversed pairs.</p> <p>This method uses itertools.permutations with length=2, but filters out pairs where both elements are the same.</p>"},{"location":"api/slist/#slist.Slist.permutations_pairs--returns","title":"Returns","text":"<p>Slist[Tuple[A, A]]     A new Slist containing all pairs of elements</p>"},{"location":"api/slist/#slist.Slist.permutations_pairs--examples","title":"Examples","text":"<p>Slist([1, 2]).permutations_pairs() Slist([(1, 2), (2, 1)]) Slist([1, 2, 3]).permutations_pairs() Slist([(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]) Slist([]).permutations_pairs() Slist([]) Slist([1]).permutations_pairs() Slist([])</p> Source code in <code>slist/__init__.py</code> <pre><code>def permutations_pairs(self) -&gt; Slist[Tuple[A, A]]:\n    \"\"\"Generate all possible pairs of elements, including reversed pairs.\n\n    This method uses itertools.permutations with length=2,\n    but filters out pairs where both elements are the same.\n\n    Returns\n    -------\n    Slist[Tuple[A, A]]\n        A new Slist containing all pairs of elements\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2]).permutations_pairs()\n    Slist([(1, 2), (2, 1)])\n    &gt;&gt;&gt; Slist([1, 2, 3]).permutations_pairs()\n    Slist([(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)])\n    &gt;&gt;&gt; Slist([]).permutations_pairs()\n    Slist([])\n    &gt;&gt;&gt; Slist([1]).permutations_pairs()\n    Slist([])\n    \"\"\"\n    result = Slist(perm for perm in itertools.permutations(self, 2))\n    return result\n</code></pre>"},{"location":"api/slist/#slist.Slist.combinations_pairs","title":"combinations_pairs","text":"<pre><code>combinations_pairs() -&gt; Slist[Tuple[A, A]]\n</code></pre> <p>Generate pairs of elements without including reversed pairs.</p> <p>This method uses itertools.combinations with length=2.</p>"},{"location":"api/slist/#slist.Slist.combinations_pairs--returns","title":"Returns","text":"<p>Slist[Tuple[A, A]]     A new Slist containing unique pairs of elements</p>"},{"location":"api/slist/#slist.Slist.combinations_pairs--examples","title":"Examples","text":"<p>Slist([1, 2]).combinations_pairs() Slist([(1, 2)]) Slist([1, 2, 3]).combinations_pairs() Slist([(1, 2), (1, 3), (2, 3)]) Slist([]).combinations_pairs() Slist([]) Slist([1]).combinations_pairs() Slist([])</p> Source code in <code>slist/__init__.py</code> <pre><code>def combinations_pairs(self) -&gt; Slist[Tuple[A, A]]:\n    \"\"\"Generate pairs of elements without including reversed pairs.\n\n    This method uses itertools.combinations with length=2.\n\n    Returns\n    -------\n    Slist[Tuple[A, A]]\n        A new Slist containing unique pairs of elements\n\n    Examples\n    --------\n    &gt;&gt;&gt; Slist([1, 2]).combinations_pairs()\n    Slist([(1, 2)])\n    &gt;&gt;&gt; Slist([1, 2, 3]).combinations_pairs()\n    Slist([(1, 2), (1, 3), (2, 3)])\n    &gt;&gt;&gt; Slist([]).combinations_pairs()\n    Slist([])\n    &gt;&gt;&gt; Slist([1]).combinations_pairs()\n    Slist([])\n    \"\"\"\n    result = Slist(itertools.combinations(self, 2))\n    return result\n</code></pre>"},{"location":"api/slist/#helper-classes","title":"Helper Classes","text":""},{"location":"api/slist/#group","title":"Group","text":""},{"location":"api/slist/#slist.Group","title":"slist.Group","text":"<p>               Bases: <code>NamedTuple</code>, <code>Generic[A_co, B_co]</code></p> <p>This is a NamedTuple so that you can easily access the key and values</p> Source code in <code>slist/__init__.py</code> <pre><code>class Group(NamedTuple, Generic[A_co, B_co]):\n    \"\"\"This is a NamedTuple so that you can easily access the key and values\"\"\"\n\n    key: A_co\n    values: B_co\n\n    def map_key(self, func: Callable[[A_co], C]) -&gt; Group[C, B_co]:\n        return Group(func(self.key), self.values)\n\n    def map_values(self, func: Callable[[B_co], C]) -&gt; Group[A_co, C]:\n        return Group(self.key, func(self.values))\n</code></pre>"},{"location":"api/slist/#slist.Group-attributes","title":"Attributes","text":""},{"location":"api/slist/#slist.Group.key","title":"key  <code>instance-attribute</code>","text":"<pre><code>key: A_co\n</code></pre>"},{"location":"api/slist/#slist.Group.values","title":"values  <code>instance-attribute</code>","text":"<pre><code>values: B_co\n</code></pre>"},{"location":"api/slist/#slist.Group-functions","title":"Functions","text":""},{"location":"api/slist/#slist.Group.map_key","title":"map_key","text":"<pre><code>map_key(func: Callable[[A_co], C]) -&gt; Group[C, B_co]\n</code></pre> Source code in <code>slist/__init__.py</code> <pre><code>def map_key(self, func: Callable[[A_co], C]) -&gt; Group[C, B_co]:\n    return Group(func(self.key), self.values)\n</code></pre>"},{"location":"api/slist/#slist.Group.map_values","title":"map_values","text":"<pre><code>map_values(func: Callable[[B_co], C]) -&gt; Group[A_co, C]\n</code></pre> Source code in <code>slist/__init__.py</code> <pre><code>def map_values(self, func: Callable[[B_co], C]) -&gt; Group[A_co, C]:\n    return Group(self.key, func(self.values))\n</code></pre>"},{"location":"api/slist/#averagestats","title":"AverageStats","text":""},{"location":"api/slist/#slist.AverageStats","title":"slist.AverageStats  <code>dataclass</code>","text":"Source code in <code>slist/__init__.py</code> <pre><code>@dataclass(frozen=True)\nclass AverageStats:\n    average: float\n    standard_deviation: float\n    upper_confidence_interval_95: float\n    lower_confidence_interval_95: float\n    average_plus_minus_95: float\n    count: int\n\n    def __str__(self) -&gt; str:\n        return f\"Average: {self.average}, SD: {self.standard_deviation}, 95% CI: ({self.lower_confidence_interval_95}, {self.upper_confidence_interval_95})\"\n</code></pre>"},{"location":"api/slist/#slist.AverageStats-attributes","title":"Attributes","text":""},{"location":"api/slist/#slist.AverageStats.average","title":"average  <code>instance-attribute</code>","text":"<pre><code>average: float\n</code></pre>"},{"location":"api/slist/#slist.AverageStats.standard_deviation","title":"standard_deviation  <code>instance-attribute</code>","text":"<pre><code>standard_deviation: float\n</code></pre>"},{"location":"api/slist/#slist.AverageStats.upper_confidence_interval_95","title":"upper_confidence_interval_95  <code>instance-attribute</code>","text":"<pre><code>upper_confidence_interval_95: float\n</code></pre>"},{"location":"api/slist/#slist.AverageStats.lower_confidence_interval_95","title":"lower_confidence_interval_95  <code>instance-attribute</code>","text":"<pre><code>lower_confidence_interval_95: float\n</code></pre>"},{"location":"api/slist/#slist.AverageStats.average_plus_minus_95","title":"average_plus_minus_95  <code>instance-attribute</code>","text":"<pre><code>average_plus_minus_95: float\n</code></pre>"},{"location":"api/slist/#slist.AverageStats.count","title":"count  <code>instance-attribute</code>","text":"<pre><code>count: int\n</code></pre>"}]}